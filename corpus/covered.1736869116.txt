/mnt/c/Users/zerox/repos/bera.buzz-contracts/contracts/BuzzToken.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.19;
  3 |     | 
  4 |     | import {ERC20} from "@openzeppelin/contracts/token/ERC20/ERC20.sol";
  5 |     | import {AccessControl} from "@openzeppelin/contracts/access/AccessControl.sol";
  6 |     | import {IBuzzToken} from "./interfaces/IBuzzToken.sol";
  7 |     | 
  8 |     | /**
  9 |     |  * @title BuzzToken
 10 |     |  * @notice This contract is the ERC20 token wrapper for bera.buzz
 11 |     |  * @author nexusflip, 0xMitzie
 12 |     |  */
 13 | *   | contract BuzzToken is ERC20, AccessControl, IBuzzToken {
 14 |     |     /// @dev access control minter role.
 15 |     |     bytes32 public immutable MINTER_ROLE;
 16 |     |     /// @dev The number of decimals
 17 |     |     uint8 private constant DECIMALS = 18;
 18 |     | 
 19 | *   |     constructor(
 20 |     |         string memory name,
 21 |     |         string memory symbol,
 22 |     |         uint256 _initialSupply,
 23 |     |         address mintTo,
 24 |     |         address _owner
 25 | *   |     ) ERC20(name, symbol) {
 26 | *   |         _mint(mintTo, _initialSupply);
 27 | *   |         MINTER_ROLE = keccak256("MINTER_ROLE");
 28 | *   |         _grantRole(MINTER_ROLE, _owner);
 29 |     |     }
 30 |     | 
 31 |     |     function mint(
 32 |     |         address account,
 33 |     |         uint256 amount
 34 |     |     ) external onlyRole(MINTER_ROLE) {
 35 |     |         _mint(account, amount);
 36 |     |     }
 37 |     | 
 38 |     |     function totalSupply()
 39 |     |         public
 40 |     |         view
 41 |     |         override(ERC20, IBuzzToken)
 42 |     |         returns (uint256)
 43 |     |     {
 44 |     |         return super.totalSupply();
 45 |     |     }
 46 |     | 
 47 |     |     function decimals() public pure override returns (uint8 _decimals) {
 48 |     |         _decimals = DECIMALS;
 49 |     |     }
 50 |     | }
 51 |     | 

/mnt/c/Users/zerox/repos/bera.buzz-contracts/contracts/BuzzTokenFactory.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity ^0.8.19;
   3 |     | 
   4 |     | import {AccessControl} from "@openzeppelin/contracts/access/AccessControl.sol";
   5 |     | import {SafeERC20} from "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
   6 |     | import {BuzzToken} from "./BuzzToken.sol";
   7 |     | import {ICREATE3Factory} from "./interfaces/create3/ICREATE3Factory.sol";
   8 |     | import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
   9 |     | import {IBuzzTokenFactory} from "./interfaces/IBuzzTokenFactory.sol";
  10 |     | import {IBuzzVault} from "./interfaces/IBuzzVault.sol";
  11 |     | import {IFeeManager} from "./interfaces/IFeeManager.sol";
  12 |     | 
  13 |     | /**
  14 |     |  * @title BuzzTokenFactory
  15 |     |  * @notice This contract is the factory for deploying new tokens
  16 |     |  * @author nexusflip, 0xMitzie
  17 |     |  */
  18 | *   | contract BuzzTokenFactory is AccessControl, IBuzzTokenFactory {
  19 |     |     using SafeERC20 for IERC20;
  20 |     | 
  21 |     |     /// @notice Event emitted when a new token is created
  22 |     |     event TokenCreated(
  23 |     |         address indexed token,
  24 |     |         address indexed baseToken,
  25 |     |         address indexed vault,
  26 |     |         address deployer,
  27 |     |         string name,
  28 |     |         string symbol
  29 |     |     );
  30 |     |     /// @notice Event emitted when a vault address is enabled or disabled
  31 |     |     event VaultSet(address indexed vault, bool status);
  32 |     |     /// @notice Event emitted when token creation is enabled or disabled
  33 |     |     event TokenCreationSet(bool status);
  34 |     |     /// @notice Event emitted when the fee manager address is set
  35 |     |     event FeeManagerSet(address indexed feeManager);
  36 |     |     /// @notice Event emitted when a base token address is enabled or disabled
  37 |     |     event BaseTokenWhitelisted(
  38 |     |         address indexed baseToken,
  39 |     |         uint256 minReserveAmount,
  40 |     |         uint256 minRaiseAmount,
  41 |     |         bool enabled
  42 |     |     );
  43 |     | 
  44 |     |     /// @notice Error code emitted when token creation is disabled
  45 |     |     error BuzzToken_TokenCreationDisabled();
  46 |     |     /// @notice Error code emitted when the vault is not registered
  47 |     |     error BuzzToken_VaultNotRegistered();
  48 |     |     /// @notice Error code emitted when the address is zero
  49 |     |     error BuzzToken_AddressZero();
  50 |     |     /// @notice Error code emitted when the listing fee is insufficient
  51 |     |     error BuzzToken_InsufficientFee();
  52 |     |     /// @notice Error code emitted when the fee transfer failed
  53 |     |     error BuzzToken_FeeTransferFailed();
  54 |     |     /// @notice Error code emitted when the base amount is not enough to complete the autobuy transaction
  55 |     |     error BuzzToken_BaseAmountNotEnough();
  56 |     |     /// @notice Error code emitted when the base token address is not whitelisted
  57 |     |     error BuzzToken_BaseTokenNotWhitelisted();
  58 |     |     /// @notice Error code emitted when the initial reserves are invalid
  59 |     |     error BuzzToken_InvalidInitialReserves();
  60 |     |     /// @notice Error code emitted when the final reserves are invalid
  61 |     |     error BuzzToken_InvalidFinalReserves();
  62 |     |     /// @notice Error code emitted when the token name is invalid
  63 |     |     error BuzzToken_InvalidTokenName();
  64 |     |     /// @notice Error code emitted when the token symbol is invalid
  65 |     |     error BuzzToken_InvalidTokenSymbol();
  66 |     | 
  67 |     |     /**
  68 |     |      * @notice Struct containing the minimum reserve and raise amounts for a base token
  69 |     |      * @param minReserveAmount The minimum reserve amount
  70 |     |      * @param minRaiseAmount The minimum raise amount
  71 |     |      */
  72 |     |     struct RaiseInfo {
  73 |     |         uint256 minReserveAmount;
  74 |     |         uint256 minRaiseAmount;
  75 |     |     }
  76 |     | 
  77 |     |     /// @notice The fee manager contract collecting the listing fee
  78 |     |     IFeeManager public feeManager;
  79 |     | 
  80 |     |     /// @notice The initial supply of the token
  81 | *   |     uint256 public constant INITIAL_SUPPLY = 1e27;
  82 |     |     /// @dev access control owner role.
  83 |     |     bytes32 public immutable OWNER_ROLE;
  84 |     |     /// @notice The address of the CREATE3 deployer
  85 |     |     address public immutable CREATE_DEPLOYER;
  86 |     |     /// @notice Whether token creation is allowed. Controlled by accounts holding OWNER_ROLE.
  87 |     |     bool public allowTokenCreation;
  88 |     | 
  89 |     |     /// @notice A mapping of whitelisted vault addresses that can be used as vaults
  90 |     |     mapping(address => bool) public vaults;
  91 |     |     /// @notice A mapping of whitelisted base token addresses that can be used to deploy tokens
  92 |     |     mapping(address => bool) public whitelistedBaseTokens;
  93 |     |     /// @notice A mapping of deployed tokens via this factory
  94 |     |     mapping(address => bool) public isDeployed;
  95 |     |     /// @notice A mapping of minimum reserve and raise amounts for a base token
  96 |     |     mapping(address => RaiseInfo) public raiseAmounts;
  97 |     | 
  98 |     |     /**
  99 |     |      * @notice Constructor of the Token Factory contract
 100 |     |      * @param _owner The owner of the contract
 101 |     |      * @param _createDeployer The address of the CREATE3 deployer
 102 |     |      * @param _feeManager The address of the feeManager contract
 103 |     |      */
 104 | *   |     constructor(address _owner, address _createDeployer, address _feeManager) {
 105 | *   |         OWNER_ROLE = keccak256("OWNER_ROLE");
 106 | *   |         _grantRole(OWNER_ROLE, _owner);
 107 |     | 
 108 | *   |         CREATE_DEPLOYER = _createDeployer;
 109 | *   |         feeManager = IFeeManager(_feeManager);
 110 |     | 
 111 | *   |         emit FeeManagerSet(_feeManager);
 112 |     |     }
 113 |     | 
 114 |     |     /**
 115 |     |      * @notice Deploys a new token
 116 |     |      * @dev Msg.value should be greater or equal to the listing fee.
 117 |     |      * @param metadata A string array containing the name and symbol of the token
 118 |     |      * @param addr An address array containing the addresses for baseToken and vault
 119 |     |      * @param raiseData An array containing the reserve data for the token
 120 |     |      * @param baseAmount The amount of base token used to buy the new token after deployment
 121 |     |      * @param salt The salt for the CREATE3 deployment
 122 |     |      */
 123 | *   |     function createToken(
 124 |     |         string[2] calldata metadata, //name, symbol
 125 |     |         address[2] calldata addr, //baseToken, vault
 126 |     |         uint256[2] calldata raiseData, //initialReserves, finalReserves
 127 |     |         uint256 baseAmount,
 128 |     |         bytes32 salt
 129 | *   |     ) external payable returns (address token) {
 130 | *   |         if (!allowTokenCreation) revert BuzzToken_TokenCreationDisabled();
 131 | *   |         if (addr[0] == address(0)) revert BuzzToken_AddressZero();
 132 | *   |         if (!vaults[addr[1]]) revert BuzzToken_VaultNotRegistered();
 133 | *   |         if (bytes(metadata[0]).length == 0) revert BuzzToken_InvalidTokenName();
 134 | *   |         if (bytes(metadata[1]).length == 0)
 135 |     |             revert BuzzToken_InvalidTokenSymbol();
 136 | *   |         if (!whitelistedBaseTokens[addr[0]])
 137 |     |             revert BuzzToken_BaseTokenNotWhitelisted();
 138 | *   |         if (raiseData[0] < raiseAmounts[addr[0]].minReserveAmount)
 139 |     |             revert BuzzToken_InvalidInitialReserves();
 140 | *   |         if (raiseData[1] < raiseData[0] + raiseAmounts[addr[0]].minRaiseAmount)
 141 |     |             revert BuzzToken_InvalidFinalReserves();
 142 |     | 
 143 | *   |         uint256 listingFee = feeManager.listingFee();
 144 | *   |         if (listingFee > 0) {
 145 | *   |             if (msg.value < listingFee) revert BuzzToken_InsufficientFee();
 146 | *   |             feeManager.collectListingFee{value: listingFee}();
 147 |     |         }
 148 |     | 
 149 | *   |         token = _deployToken(
 150 | *   |             metadata[0],
 151 | *   |             metadata[1],
 152 | *   |             addr[0],
 153 | *   |             addr[1],
 154 | *   |             salt,
 155 | *   |             raiseData
 156 |     |         );
 157 | *   |         emit TokenCreated(
 158 | *   |             token,
 159 | *   |             addr[0],
 160 | *   |             addr[1],
 161 | *   |             msg.sender,
 162 | *   |             metadata[0],
 163 | *   |             metadata[1]
 164 |     |         );
 165 |     | 
 166 | *   |         if (baseAmount > 0) {
 167 |     |             if ((msg.value - listingFee) > 0) {
 168 |     |                 // Buy tokens using excess msg.value. baseToken == wbera check occurs in Vault contract
 169 |     |                 uint256 remainingValue = msg.value - listingFee;
 170 |     |                 if (remainingValue != baseAmount)
 171 |     |                     revert BuzzToken_BaseAmountNotEnough();
 172 |     |                 IBuzzVault(addr[1]).buyNative{value: remainingValue}(
 173 |     |                     token,
 174 |     |                     1e15,
 175 |     |                     address(0),
 176 |     |                     msg.sender
 177 |     |                 );
 178 |     |             } else {
 179 |     |                 // Buy tokens using base token
 180 |     |                 IERC20(addr[0]).safeTransferFrom(
 181 |     |                     msg.sender,
 182 |     |                     address(this),
 183 |     |                     baseAmount
 184 |     |                 );
 185 |     |                 IERC20(addr[0]).safeApprove(addr[1], baseAmount);
 186 |     |                 IBuzzVault(addr[1]).buy(
 187 |     |                     token,
 188 |     |                     baseAmount,
 189 |     |                     1e15,
 190 |     |                     address(0),
 191 |     |                     msg.sender
 192 |     |                 );
 193 |     |             }
 194 |     |         }
 195 |     |     }
 196 |     | 
 197 |     |     /**
 198 |     |      * @notice Enables or disables a vault address that can be used to deploy tokens
 199 |     |      * @param vault The address of the vault
 200 |     |      * @param enable The status of the vault
 201 |     |      */
 202 | *   |     function setVault(
 203 |     |         address vault,
 204 |     |         bool enable
 205 | *   |     ) external onlyRole(OWNER_ROLE) {
 206 | *   |         if (vault == address(0)) revert BuzzToken_AddressZero();
 207 |     | 
 208 | *   |         vaults[vault] = enable;
 209 | *   |         emit VaultSet(vault, enable);
 210 |     |     }
 211 |     | 
 212 |     |     /**
 213 |     |      * @notice Enables or disables token creation
 214 |     |      * @param allowTokenCreation_ The status of token creation
 215 |     |      */
 216 | *   |     function setAllowTokenCreation(
 217 |     |         bool allowTokenCreation_
 218 | *   |     ) external onlyRole(OWNER_ROLE) {
 219 | *   |         allowTokenCreation = allowTokenCreation_;
 220 |     | 
 221 | *   |         emit TokenCreationSet(allowTokenCreation);
 222 |     |     }
 223 |     | 
 224 |     |     /**
 225 |     |      * @notice Sets the fee manager address
 226 |     |      * @param feeManager_ The address of the fee manager contract
 227 |     |      */
 228 |     |     function setFeeManager(
 229 |     |         address payable feeManager_
 230 |     |     ) external onlyRole(OWNER_ROLE) {
 231 |     |         if (feeManager_ == address(0)) revert BuzzToken_AddressZero();
 232 |     | 
 233 |     |         feeManager = IFeeManager(feeManager_);
 234 |     |         emit FeeManagerSet(feeManager_);
 235 |     |     }
 236 |     | 
 237 |     |     /**
 238 |     |      * @notice Enables or disables a base token address that can be used to deploy tokens
 239 |     |      * @param baseToken The address of the base token
 240 |     |      * @param minReserveAmount The minimum reserve amount
 241 |     |      * @param minRaiseAmount The minimum raise amount
 242 |     |      * @param enable True to whitelist, false to remove from the whitelist
 243 |     |      */
 244 | *   |     function setAllowedBaseToken(
 245 |     |         address baseToken,
 246 |     |         uint256 minReserveAmount,
 247 |     |         uint256 minRaiseAmount,
 248 |     |         bool enable
 249 | *   |     ) external onlyRole(OWNER_ROLE) {
 250 | *   |         if (baseToken == address(0)) revert BuzzToken_AddressZero();
 251 |     | 
 252 | *   |         if (
 253 | *   |             raiseAmounts[baseToken].minReserveAmount == 0 &&
 254 | *   |             raiseAmounts[baseToken].minRaiseAmount == 0
 255 |     |         ) {
 256 | *   |             raiseAmounts[baseToken] = RaiseInfo(
 257 | *   |                 minReserveAmount,
 258 | *   |                 minRaiseAmount
 259 |     |             );
 260 |     |         } else {
 261 |     |             raiseAmounts[baseToken].minReserveAmount = minReserveAmount;
 262 |     |             raiseAmounts[baseToken].minRaiseAmount = minRaiseAmount;
 263 |     |         }
 264 | *   |         whitelistedBaseTokens[baseToken] = enable;
 265 |     | 
 266 | *   |         emit BaseTokenWhitelisted(
 267 | *   |             baseToken,
 268 | *   |             minReserveAmount,
 269 | *   |             minRaiseAmount,
 270 | *   |             enable
 271 |     |         );
 272 |     |     }
 273 |     | 
 274 |     |     /**
 275 |     |      * @notice Deploys a new token using CREATE3
 276 |     |      * @param name The name of the token
 277 |     |      * @param symbol The symbol of the token
 278 |     |      * @param baseToken The address of the base token
 279 |     |      * @param vault The address of the vault
 280 |     |      * @param salt The salt for the CREATE3 deployment
 281 |     |      * @param raiseData An array containing the reserve data for the token
 282 |     |      * @return token The address of the deployed token
 283 |     |      */
 284 | *   |     function _deployToken(
 285 |     |         string calldata name,
 286 |     |         string calldata symbol,
 287 |     |         address baseToken,
 288 |     |         address vault,
 289 |     |         bytes32 salt,
 290 |     |         uint256[2] calldata raiseData
 291 | *   |     ) internal returns (address token) {
 292 | *   |         uint256 initialReserves = raiseData[0];
 293 | *   |         uint256 finalReserves = raiseData[1];
 294 | *   |         uint256 initialSupply = INITIAL_SUPPLY;
 295 |     | 
 296 | *   |         bytes memory bytecode = abi.encodePacked(
 297 | *   |             type(BuzzToken).creationCode,
 298 | *   |             abi.encode(name, symbol, initialSupply, address(this), vault)
 299 |     |         );
 300 |     | 
 301 | *   |         token = ICREATE3Factory(CREATE_DEPLOYER).getDeployed(
 302 | *   |             address(this),
 303 | *   |             salt
 304 |     |         );
 305 | *   |         isDeployed[token] = true;
 306 |     | 
 307 | *   |         ICREATE3Factory(CREATE_DEPLOYER).deploy(salt, bytecode);
 308 |     | 
 309 | *   |         IERC20(token).safeApprove(vault, initialSupply);
 310 | *   |         IBuzzVault(vault).registerToken(
 311 | *   |             token,
 312 | *   |             baseToken,
 313 | *   |             initialSupply,
 314 | *   |             initialReserves,
 315 | *   |             finalReserves
 316 |     |         );
 317 |     |     }
 318 |     | }
 319 |     | 

/mnt/c/Users/zerox/repos/bera.buzz-contracts/contracts/BuzzVault.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity ^0.8.19;
   3 |     | 
   4 |     | import {Ownable} from "@openzeppelin/contracts/access/Ownable.sol";
   5 |     | import {Pausable} from "@openzeppelin/contracts/security/Pausable.sol";
   6 |     | import {SafeERC20} from "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
   7 |     | import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
   8 |     | import {IWBera} from "./interfaces/IWBera.sol";
   9 |     | import {IBexLiquidityManager} from "./interfaces/IBexLiquidityManager.sol";
  10 |     | import {IReferralManager} from "./interfaces/IReferralManager.sol";
  11 |     | import {IBuzzVault} from "./interfaces/IBuzzVault.sol";
  12 |     | import {IFeeManager} from "./interfaces/IFeeManager.sol";
  13 |     | 
  14 |     | /**
  15 |     |  * @title BuzzVault contract
  16 |     |  * @notice An abstract contract holding logic for bonding curve operations
  17 |     |  * @author nexusflip, 0xMitzie
  18 |     |  */
  19 |     | abstract contract BuzzVault is Ownable, Pausable, IBuzzVault {
  20 |     |     using SafeERC20 for IERC20;
  21 |     | 
  22 |     |     /// @notice Event emitted when a trade occurs
  23 |     |     event Trade(
  24 |     |         address indexed user,
  25 |     |         address indexed token,
  26 |     |         address indexed baseToken,
  27 |     |         uint256 tokenAmount,
  28 |     |         uint256 baseAmount,
  29 |     |         uint256 tokenBalance,
  30 |     |         uint256 baseBalance,
  31 |     |         bool isBuyOrder
  32 |     |     );
  33 |     |     /// @notice Event emitted when a token is registered
  34 |     |     event TokenRegistered(
  35 |     |         address indexed token,
  36 |     |         address indexed baseToken,
  37 |     |         uint256 tokenBalance,
  38 |     |         uint256 initialReserves,
  39 |     |         uint256 finalReserves
  40 |     |     );
  41 |     | 
  42 |     |     /// @notice Error code emitted when the quote amount in buy/sell is zero
  43 |     |     error BuzzVault_QuoteAmountZero();
  44 |     |     /// @notice Error code emitted when the reserves are invalid
  45 |     |     error BuzzVault_InvalidReserves();
  46 |     |     /// @notice Error code emitted when user balance is invalid
  47 |     |     error BuzzVault_InvalidUserBalance();
  48 |     |     /// @notice Error code emitted when the token is not listed in Bex
  49 |     |     error BuzzVault_BexListed();
  50 |     |     /// @notice Error code emitted when the token is tracked in the curve
  51 |     |     error BuzzVault_UnknownToken();
  52 |     |     /// @notice Error code emitted when the slippage is exceeded
  53 |     |     error BuzzVault_SlippageExceeded();
  54 |     |     /// @notice Error code emitted when the fee transfer fails
  55 |     |     error BuzzVault_FeeTransferFailed();
  56 |     |     /// @notice Error code emitted when the caller is not authorized
  57 |     |     error BuzzVault_Unauthorized();
  58 |     |     /// @notice Error code emitted when the token already exists
  59 |     |     error BuzzVault_TokenExists();
  60 |     |     /// @notice Error code emitted when native trades with ETH is not supported
  61 |     |     error BuzzVault_NativeTradeUnsupported();
  62 |     |     /// @notice Error code emitted when WBera transfer fails (depositing or withdrawing)
  63 |     |     error BuzzVault_WBeraConversionFailed();
  64 |     |     /// @notice Error code emitted when the recipient is the zero address
  65 |     |     error BuzzVault_AddressZeroRecipient();
  66 |     |     /// @notice Error code emitted when the token is the zero address
  67 |     |     error BuzzVault_AddressZeroToken();
  68 |     | 
  69 |     |     /**
  70 |     |      * @notice Data about a token in the bonding curve
  71 |     |      * @param baseToken The base token address
  72 |     |      * @param bexListed Whether the token is listed in Bex
  73 |     |      * @param tokenBalance The token balance
  74 |     |      * @param baseBalance The base amount balance
  75 |     |      * @param initialBase The initial base amount
  76 |     |      * @param baseThreshold The amount of bera on the curve to lock it
  77 |     |      * @param quoteThreshold The amount of tokens on the curve to lock it
  78 |     |      * @param k The k value of the token
  79 |     |      */
  80 |     |     struct TokenInfo {
  81 |     |         address baseToken;
  82 |     |         bool bexListed;
  83 |     |         uint256 tokenBalance;
  84 |     |         uint256 baseBalance; // aka reserve balance
  85 |     |         uint256 initialBase;
  86 |     |         uint256 baseThreshold;
  87 |     |         uint256 quoteThreshold;
  88 |     |         uint256 k;
  89 |     |     }
  90 |     | 
  91 |     |     /// @notice The fee manager contract collecting protocol fees
  92 |     |     IFeeManager public immutable FEE_MANAGER;
  93 |     |     /// @notice The referral manager contract
  94 |     |     IReferralManager public immutable REFERRAL_MANAGER;
  95 |     |     /// @notice The liquidity manager contract
  96 |     |     IBexLiquidityManager public immutable LIQUIDITY_MANAGER;
  97 |     |     /// @notice The WBERA contract
  98 |     |     IWBera public immutable WBERA;
  99 |     | 
 100 |     |     /// @notice The factory contract that can register tokens
 101 |     |     address public immutable FACTORY;
 102 |     | 
 103 |     |     /// @notice Map token address to token info
 104 | *   |     mapping(address => TokenInfo) public tokenInfo;
 105 |     | 
 106 |     |     /**
 107 |     |      * @notice Constructor for a new BuzzVault contract
 108 |     |      * @param _feeManager The address of the fee manager contract collecting fees
 109 |     |      * @param _factory The factory contract that can register tokens
 110 |     |      * @param _referralManager The referral manager contract
 111 |     |      * @param _liquidityManager The liquidity manager contract
 112 |     |      * @param _wbera The WBERA contract
 113 |     |      */
 114 | *   |     constructor(
 115 |     |         address _feeManager,
 116 |     |         address _factory,
 117 |     |         address _referralManager,
 118 |     |         address _liquidityManager,
 119 |     |         address _wbera
 120 |     |     ) {
 121 | *   |         FACTORY = _factory;
 122 | *   |         FEE_MANAGER = IFeeManager(_feeManager);
 123 | *   |         REFERRAL_MANAGER = IReferralManager(_referralManager);
 124 | *   |         LIQUIDITY_MANAGER = IBexLiquidityManager(_liquidityManager);
 125 | *   |         WBERA = IWBera(_wbera);
 126 |     |     }
 127 |     | 
 128 |     |     // Fallback function
 129 |     |     receive() external payable {}
 130 |     | 
 131 |     |     /**
 132 |     |      * @notice Buy tokens from the vault with the native currency. The base token of the token must be WBera
 133 |     |      * @param token The token address
 134 |     |      * @param minTokensOut The minimum amount of tokens to buy, will revert if slippage exceeds this value
 135 |     |      * @param affiliate The affiliate address, zero address if none
 136 |     |      * @param recipient The recipient address
 137 |     |      */
 138 |     |     function buyNative(
 139 |     |         address token,
 140 |     |         uint256 minTokensOut,
 141 |     |         address affiliate,
 142 |     |         address recipient
 143 |     |     ) external payable override whenNotPaused {
 144 |     |         if (msg.value == 0) revert BuzzVault_QuoteAmountZero();
 145 |     |         if (recipient == address(0)) revert BuzzVault_AddressZeroRecipient();
 146 |     |         if (token == address(0)) revert BuzzVault_AddressZeroToken();
 147 |     | 
 148 |     |         uint256 baseAmount;
 149 |     |         if (tokenInfo[token].baseToken == address(WBERA)) {
 150 |     |             uint256 balancePrior = WBERA.balanceOf(address(this));
 151 |     |             WBERA.deposit{value: msg.value}();
 152 |     |             baseAmount = WBERA.balanceOf(address(this)) - balancePrior;
 153 |     |             if (baseAmount != msg.value)
 154 |     |                 revert BuzzVault_WBeraConversionFailed();
 155 |     |         } else {
 156 |     |             revert BuzzVault_NativeTradeUnsupported();
 157 |     |         }
 158 |     | 
 159 |     |         _buyTokens(token, baseAmount, minTokensOut, affiliate, recipient);
 160 |     |     }
 161 |     | 
 162 |     |     /**
 163 |     |      * @notice Buy tokens from the vault using the base token (ERC20)
 164 |     |      * @param token The token address
 165 |     |      * @param baseAmount The amount of base tokens to buy with
 166 |     |      * @param minTokensOut The minimum amount of tokens to buy, will revert if slippage exceeds this value
 167 |     |      * @param affiliate The affiliate address, zero address if none
 168 |     |      * @param recipient The recipient address
 169 |     |      */
 170 |     |     function buy(
 171 |     |         address token,
 172 |     |         uint256 baseAmount,
 173 |     |         uint256 minTokensOut,
 174 |     |         address affiliate,
 175 |     |         address recipient
 176 |     |     ) external override whenNotPaused {
 177 |     |         if (baseAmount == 0) revert BuzzVault_QuoteAmountZero();
 178 |     |         if (recipient == address(0)) revert BuzzVault_AddressZeroRecipient();
 179 |     |         if (token == address(0)) revert BuzzVault_AddressZeroToken();
 180 |     | 
 181 |     |         IERC20(tokenInfo[token].baseToken).safeTransferFrom(
 182 |     |             msg.sender,
 183 |     |             address(this),
 184 |     |             baseAmount
 185 |     |         );
 186 |     |         _buyTokens(token, baseAmount, minTokensOut, affiliate, recipient);
 187 |     |     }
 188 |     | 
 189 |     |     /**
 190 |     |      * @notice Sell tokens to the vault for base tokens
 191 |     |      * @param token The (quote) token address
 192 |     |      * @param tokenAmount The amount of (quote) tokens to sell
 193 |     |      * @param minAmountOut The minimum amount of base tokens to receive, will revert if slippage exceeds this value
 194 |     |      * @param affiliate The affiliate address, zero address if none
 195 |     |      * @param recipient The recipient address
 196 |     |      * @param unwrap Whether to unwrap the WBERA tokens to BERA
 197 |     |      */
 198 |     |     function sell(
 199 |     |         address token,
 200 |     |         uint256 tokenAmount,
 201 |     |         uint256 minAmountOut,
 202 |     |         address affiliate,
 203 |     |         address recipient,
 204 |     |         bool unwrap
 205 |     |     ) external override whenNotPaused {
 206 |     |         if (tokenAmount == 0) revert BuzzVault_QuoteAmountZero();
 207 |     |         if (recipient == address(0)) revert BuzzVault_AddressZeroRecipient();
 208 |     |         if (token == address(0)) revert BuzzVault_AddressZeroToken();
 209 |     | 
 210 |     |         TokenInfo storage info = tokenInfo[token];
 211 |     |         if (info.bexListed) revert BuzzVault_BexListed();
 212 |     |         if (info.tokenBalance == 0 && info.baseBalance == 0)
 213 |     |             revert BuzzVault_UnknownToken();
 214 |     | 
 215 |     |         if (IERC20(token).balanceOf(msg.sender) < tokenAmount)
 216 |     |             revert BuzzVault_InvalidUserBalance();
 217 |     | 
 218 |     |         if (affiliate != address(0)) _setReferral(affiliate, msg.sender);
 219 |     | 
 220 |     |         uint256 amountSold = _sell(
 221 |     |             token,
 222 |     |             tokenAmount,
 223 |     |             minAmountOut,
 224 |     |             recipient,
 225 |     |             info,
 226 |     |             unwrap
 227 |     |         );
 228 |     |         emit Trade(
 229 |     |             recipient,
 230 |     |             token,
 231 |     |             info.baseToken,
 232 |     |             tokenAmount,
 233 |     |             amountSold,
 234 |     |             info.tokenBalance,
 235 |     |             info.baseBalance,
 236 |     |             false
 237 |     |         );
 238 |     |     }
 239 |     | 
 240 |     |     /**
 241 |     |      * @notice Register a token in the vault
 242 |     |      * @dev Only the factory can register tokens
 243 |     |      * @param token The token address
 244 |     |      * @param baseToken The base token address
 245 |     |      * @param initialTokenBalance The initial quote token balance
 246 |     |      * @param initialReserves The initial virtual base token reserves
 247 |     |      * @param finalReserves The target virtual base token reserves
 248 |     |      */
 249 | *   |     function registerToken(
 250 |     |         address token,
 251 |     |         address baseToken,
 252 |     |         uint256 initialTokenBalance,
 253 |     |         uint256 initialReserves,
 254 |     |         uint256 finalReserves
 255 | *   |     ) external override {
 256 | *   |         if (msg.sender != FACTORY) revert BuzzVault_Unauthorized();
 257 | *   |         if (
 258 | *   |             tokenInfo[token].tokenBalance > 0 ||
 259 | *   |             tokenInfo[token].baseBalance > 0
 260 |     |         ) revert BuzzVault_TokenExists();
 261 |     | 
 262 | *   |         uint256 k = initialReserves * initialTokenBalance;
 263 |     | 
 264 | *   |         tokenInfo[token] = TokenInfo(
 265 | *   |             baseToken,
 266 | *   |             false,
 267 | *   |             initialTokenBalance,
 268 | *   |             initialReserves,
 269 | *   |             initialReserves,
 270 | *   |             finalReserves,
 271 | *   |             k / finalReserves,
 272 | *   |             k
 273 |     |         );
 274 |     | 
 275 | *   |         IERC20(token).safeTransferFrom(
 276 | *   |             msg.sender,
 277 | *   |             address(this),
 278 | *   |             initialTokenBalance
 279 |     |         );
 280 |     | 
 281 | *   |         emit TokenRegistered(
 282 | *   |             token,
 283 | *   |             baseToken,
 284 | *   |             initialTokenBalance,
 285 | *   |             initialReserves,
 286 | *   |             finalReserves
 287 |     |         );
 288 |     |     }
 289 |     | 
 290 |     |     /**
 291 |     |      * @notice Pauses the contract
 292 |     |      * @dev Only the owner can call this function.
 293 |     |      */
 294 |     |     function pause() external onlyOwner {
 295 |     |         _pause();
 296 |     |     }
 297 |     | 
 298 |     |     /**
 299 |     |      * @notice Unpauses the contract
 300 |     |      * @dev Only the owner can call this function.
 301 |     |      */
 302 |     |     function unpause() external onlyOwner {
 303 |     |         _unpause();
 304 |     |     }
 305 |     | 
 306 |     |     /**
 307 |     |      * @notice Quote the amount of tokenIn needed to buy a certain amount of tokenOut
 308 |     |      * @param token The token address
 309 |     |      * @param amount The amount of tokens to buy
 310 |     |      * @param isBuyOrder Whether the quote is for a buy or sell order
 311 |     |      * @return amountOut The amount of base tokens needed
 312 |     |      */
 313 |     |     function quote(
 314 |     |         address token,
 315 |     |         uint256 amount,
 316 |     |         bool isBuyOrder
 317 |     |     ) external view virtual override returns (uint256 amountOut);
 318 |     | 
 319 |     |     /**
 320 |     |      * @notice Internal function to handle buy accounting
 321 |     |      * @param token The token address
 322 |     |      * @param baseAmount The amount of base tokens to buy with
 323 |     |      * @param minTokensOut The minimum amount of tokens to buy, will revert if slippage exceeds this value
 324 |     |      * @param recipient The recipient address
 325 |     |      * @return tokenAmount The amount of tokens bought
 326 |     |      * @return needsMigration Whether the curve needs to be locked and migrated
 327 |     |      */
 328 |     |     function _buy(
 329 |     |         address token,
 330 |     |         uint256 baseAmount,
 331 |     |         uint256 minTokensOut,
 332 |     |         address recipient,
 333 |     |         TokenInfo storage info
 334 |     |     ) internal virtual returns (uint256 tokenAmount, bool needsMigration);
 335 |     | 
 336 |     |     /**
 337 |     |      * @notice Internal function to handle sell accounting
 338 |     |      * @param token The token address
 339 |     |      * @param tokenAmount The amount of tokens to sell
 340 |     |      * @param minAmountOut The minimum amount of base tokens to receive, will revert if slippage exceeds this value
 341 |     |      * @param recipient The recipient address
 342 |     |      * @param info The token info struct
 343 |     |      * @param unwrap Whether to unwrap the WBERA tokens to BERA
 344 |     |      * @return netBaseAmount The amount of base tokens received
 345 |     |      */
 346 |     |     function _sell(
 347 |     |         address token,
 348 |     |         uint256 tokenAmount,
 349 |     |         uint256 minAmountOut,
 350 |     |         address recipient,
 351 |     |         TokenInfo storage info,
 352 |     |         bool unwrap
 353 |     |     ) internal virtual returns (uint256 netBaseAmount);
 354 |     | 
 355 |     |     /**
 356 |     |      * @notice Transfers bera to a recipient, checking if the transfer was successful
 357 |     |      * @param recipient The recipient address
 358 |     |      * @param amount The amount to transfer
 359 |     |      */
 360 |     |     function _transferEther(
 361 |     |         address payable recipient,
 362 |     |         uint256 amount
 363 |     |     ) internal {
 364 |     |         (bool success, ) = recipient.call{value: amount}("");
 365 |     |         if (!success) revert BuzzVault_FeeTransferFailed();
 366 |     |     }
 367 |     | 
 368 |     |     /**
 369 |     |      * @notice Locks the bonding curve and deposits the tokens in the liquidity manager
 370 |     |      * @param token The token address
 371 |     |      * @param info The token info struct
 372 |     |      */
 373 |     |     function _lockCurveAndDeposit(
 374 |     |         address token,
 375 |     |         TokenInfo storage info
 376 |     |     ) internal {
 377 |     |         uint256 tokenBalance = info.tokenBalance;
 378 |     |         uint256 baseBalance = info.baseBalance - info.initialBase;
 379 |     |         address baseToken = info.baseToken;
 380 |     | 
 381 |     |         info.bexListed = true;
 382 |     |         info.baseBalance = 0;
 383 |     |         info.tokenBalance = 0;
 384 |     |         info.initialBase = 0;
 385 |     |         info.baseThreshold = 0;
 386 |     |         info.quoteThreshold = 0;
 387 |     |         info.k = 0;
 388 |     | 
 389 |     |         // collect fee
 390 |     |         uint256 dexFee = FEE_MANAGER.quoteMigrationFee(baseBalance);
 391 |     |         IERC20(baseToken).safeApprove(address(FEE_MANAGER), dexFee);
 392 |     |         FEE_MANAGER.collectMigrationFee(baseToken, baseBalance);
 393 |     |         uint256 netBaseAmount = baseBalance - dexFee;
 394 |     | 
 395 |     |         IERC20(token).safeApprove(address(LIQUIDITY_MANAGER), tokenBalance);
 396 |     |         IERC20(baseToken).safeApprove(
 397 |     |             address(LIQUIDITY_MANAGER),
 398 |     |             netBaseAmount
 399 |     |         );
 400 |     | 
 401 |     |         LIQUIDITY_MANAGER.createPoolAndAdd(
 402 |     |             token,
 403 |     |             baseToken,
 404 |     |             netBaseAmount,
 405 |     |             tokenBalance
 406 |     |         );
 407 |     | 
 408 |     |         // burn any rounding excess
 409 |     |         if (IERC20(token).balanceOf(address(this)) > 0) {
 410 |     |             IERC20(token).safeTransfer(
 411 |     |                 address(0xdead),
 412 |     |                 IERC20(token).balanceOf(address(this))
 413 |     |             );
 414 |     |         }
 415 |     |     }
 416 |     | 
 417 |     |     /**
 418 |     |      * @notice Internal function containing the peripheral logic to buy tokens from the bonding curve
 419 |     |      * @param token The token address
 420 |     |      * @param baseAmount The amount of base tokens to buy with
 421 |     |      * @param minTokensOut The minimum amount of tokens to buy, will revert if slippage exceeds this value
 422 |     |      * @param affiliate The affiliate address, zero address if none
 423 |     |      * @param recipient The recipient address
 424 |     |      */
 425 |     |     function _buyTokens(
 426 |     |         address token,
 427 |     |         uint256 baseAmount,
 428 |     |         uint256 minTokensOut,
 429 |     |         address affiliate,
 430 |     |         address recipient
 431 |     |     ) internal {
 432 |     |         TokenInfo storage info = tokenInfo[token];
 433 |     |         if (info.bexListed) revert BuzzVault_BexListed();
 434 |     |         if (info.tokenBalance == 0 && info.baseBalance == 0)
 435 |     |             revert BuzzVault_UnknownToken();
 436 |     | 
 437 |     |         uint256 contractBalance = IERC20(token).balanceOf(address(this));
 438 |     |         if (contractBalance < minTokensOut) revert BuzzVault_InvalidReserves();
 439 |     | 
 440 |     |         if (affiliate != address(0)) _setReferral(affiliate, msg.sender);
 441 |     | 
 442 |     |         (uint256 amountBought, bool needsMigration) = _buy(
 443 |     |             token,
 444 |     |             baseAmount,
 445 |     |             minTokensOut,
 446 |     |             recipient,
 447 |     |             info
 448 |     |         );
 449 |     |         emit Trade(
 450 |     |             recipient,
 451 |     |             token,
 452 |     |             info.baseToken,
 453 |     |             amountBought,
 454 |     |             baseAmount,
 455 |     |             info.tokenBalance,
 456 |     |             info.baseBalance,
 457 |     |             true
 458 |     |         );
 459 |     | 
 460 |     |         if (needsMigration) {
 461 |     |             _lockCurveAndDeposit(token, info);
 462 |     |         }
 463 |     |     }
 464 |     | 
 465 |     |     /**
 466 |     |      * @notice Registers the referral for a user in REFERRAL_MANAGER
 467 |     |      * @param referrer The referrer address
 468 |     |      * @param user The user address
 469 |     |      */
 470 |     |     function _setReferral(address referrer, address user) internal {
 471 |     |         REFERRAL_MANAGER.setReferral(referrer, user);
 472 |     |     }
 473 |     | 
 474 |     |     /**
 475 |     |      * @notice Calculates and forwards the referral fee to REFERRAL_MANAGER
 476 |     |      * @param user The user address making the trade
 477 |     |      * @param token The base token address
 478 |     |      * @param amount The base amount to calculate the fee on
 479 |     |      */
 480 |     |     function _collectReferralFee(
 481 |     |         address user,
 482 |     |         address token,
 483 |     |         uint256 amount
 484 |     |     ) internal returns (uint256 referralFee) {
 485 |     |         uint256 bps = REFERRAL_MANAGER.getReferralBpsFor(user);
 486 |     | 
 487 |     |         if (bps > 0) {
 488 |     |             referralFee = (amount * bps) / 1e4;
 489 |     |             IERC20(token).safeApprove(address(REFERRAL_MANAGER), referralFee);
 490 |     |             REFERRAL_MANAGER.receiveReferral(user, token, referralFee);
 491 |     |         }
 492 |     |     }
 493 |     | 
 494 |     |     /**
 495 |     |      * @notice Unwraps the WBERA tokens to BERA
 496 |     |      * @param to The recipient address
 497 |     |      * @param amount The amount to unwrap
 498 |     |      */
 499 |     |     function _unwrap(address to, uint256 amount) internal {
 500 |     |         uint256 balancePrior = address(this).balance;
 501 |     |         IERC20(address(WBERA)).safeApprove(address(WBERA), amount);
 502 |     | 
 503 |     |         WBERA.withdraw(amount);
 504 |     |         uint256 withdrawal = address(this).balance - balancePrior;
 505 |     |         if (withdrawal != amount) revert BuzzVault_WBeraConversionFailed();
 506 |     | 
 507 |     |         _transferEther(payable(to), amount);
 508 |     |     }
 509 |     | }
 510 |     | 

/mnt/c/Users/zerox/repos/bera.buzz-contracts/contracts/BuzzVaultExponential.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity ^0.8.19;
   3 |     | 
   4 |     | import {BuzzVault, SafeERC20, IERC20} from "./BuzzVault.sol";
   5 |     | 
   6 |     | /**
   7 |     |  * @title BuzzVaultExponential contract
   8 |     |  * @notice A contract implementing an exponential bonding curve
   9 |     |  * @author nexusflip, 0xMitzie
  10 |     |  */
  11 | *   | contract BuzzVaultExponential is BuzzVault {
  12 |     |     using SafeERC20 for IERC20;
  13 |     | 
  14 |     |     /**
  15 |     |      * @notice Constructor for a new BuzzVaultExponential contract
  16 |     |      * @param _feeManager The address of the fee manager contract collecting fees
  17 |     |      * @param _factory The factory contract that can register tokens
  18 |     |      * @param _referralManager The referral manager contract
  19 |     |      * @param _liquidityManager The liquidity manager contract
  20 |     |      * @param _wbera The address of the wrapped Bera token
  21 |     |      */
  22 | *   |     constructor(
  23 |     |         address _feeManager,
  24 |     |         address _factory,
  25 |     |         address _referralManager,
  26 |     |         address _liquidityManager,
  27 |     |         address _wbera
  28 |     |     )
  29 |     |         BuzzVault(
  30 | *   |             _feeManager,
  31 | *   |             _factory,
  32 | *   |             _referralManager,
  33 | *   |             _liquidityManager,
  34 | *   |             _wbera
  35 |     |         )
  36 |     |     {}
  37 |     | 
  38 |     |     /**
  39 |     |      * @notice Quote the amount of tokens that can be bought or sold at the current curve
  40 |     |      * @param token The quote token address
  41 |     |      * @param amount Base tokens is isBuyOrder is true, quote tokens if isBuyOrder is false
  42 |     |      * @param isBuyOrder True if buying, false if selling
  43 |     |      * @return amountOut The amount of base or quote tokens that can be bought or sold
  44 |     |      */
  45 |     |     function quote(
  46 |     |         address token,
  47 |     |         uint256 amount,
  48 |     |         bool isBuyOrder
  49 |     |     ) external view override returns (uint256 amountOut) {
  50 |     |         if (amount == 0) revert BuzzVault_QuoteAmountZero();
  51 |     |         if (token == address(0)) revert BuzzVault_AddressZeroToken();
  52 |     | 
  53 |     |         TokenInfo storage info = tokenInfo[token];
  54 |     |         if (info.bexListed) revert BuzzVault_BexListed();
  55 |     | 
  56 |     |         uint256 tokenBalance = info.tokenBalance;
  57 |     |         uint256 baseBalance = info.baseBalance;
  58 |     |         if (tokenBalance == 0 && baseBalance == 0)
  59 |     |             revert BuzzVault_UnknownToken();
  60 |     | 
  61 |     |         if (isBuyOrder) {
  62 |     |             uint256 amountAfterFee = amount -
  63 |     |                 FEE_MANAGER.quoteTradingFee(amount);
  64 |     |             (amountOut, ) = _calculateBuyPrice(
  65 |     |                 amountAfterFee,
  66 |     |                 baseBalance,
  67 |     |                 tokenBalance,
  68 |     |                 info.quoteThreshold,
  69 |     |                 info.k
  70 |     |             );
  71 |     |         } else {
  72 |     |             amountOut = _calculateSellPrice(
  73 |     |                 amount,
  74 |     |                 tokenBalance,
  75 |     |                 baseBalance,
  76 |     |                 info.k
  77 |     |             );
  78 |     |             if (amountOut > baseBalance - info.initialBase)
  79 |     |                 amountOut = baseBalance - info.initialBase;
  80 |     |             amountOut -= FEE_MANAGER.quoteTradingFee(amountOut);
  81 |     |         }
  82 |     |     }
  83 |     | 
  84 |     |     /**
  85 |     |      * @notice Buy tokens from the bonding curve
  86 |     |      * @param token The token address
  87 |     |      * @param baseAmount The base amount of tokens used to buy with
  88 |     |      * @param minTokensOut The minimum amount of tokens to buy
  89 |     |      * @param info The token info struct
  90 |     |      * @param recipient The address to send the tokens to
  91 |     |      * @return tokenAmount The amount of tokens bought
  92 |     |      */
  93 |     |     function _buy(
  94 |     |         address token,
  95 |     |         uint256 baseAmount,
  96 |     |         uint256 minTokensOut,
  97 |     |         address recipient,
  98 |     |         TokenInfo storage info
  99 |     |     ) internal override returns (uint256 tokenAmount, bool needsMigration) {
 100 |     |         uint256 tradingFee = FEE_MANAGER.quoteTradingFee(baseAmount);
 101 |     |         uint256 netBaseAmount = baseAmount - tradingFee;
 102 |     |         uint256 baseBalance = info.baseBalance;
 103 |     |         (uint256 tokenAmountBuy, bool exceeded) = _calculateBuyPrice(
 104 |     |             netBaseAmount,
 105 |     |             baseBalance,
 106 |     |             info.tokenBalance,
 107 |     |             info.quoteThreshold,
 108 |     |             info.k
 109 |     |         );
 110 |     |         if (tokenAmountBuy < minTokensOut) revert BuzzVault_SlippageExceeded();
 111 |     | 
 112 |     |         uint256 baseSurplus;
 113 |     |         if (exceeded) {
 114 |     |             uint256 basePlusNet = baseBalance + netBaseAmount;
 115 |     |             if (basePlusNet > info.baseThreshold) {
 116 |     |                 baseSurplus = basePlusNet - info.baseThreshold;
 117 |     |                 netBaseAmount -= baseSurplus;
 118 |     |             }
 119 |     |         }
 120 |     | 
 121 |     |         // Update balances
 122 |     |         info.baseBalance += netBaseAmount;
 123 |     |         info.tokenBalance -= tokenAmountBuy;
 124 |     | 
 125 |     |         // Collect trading and referral fee
 126 |     |         _collectFees(info.baseToken, msg.sender, baseAmount);
 127 |     | 
 128 |     |         // Transfer tokens to the buyer
 129 |     |         IERC20(token).safeTransfer(recipient, tokenAmountBuy);
 130 |     | 
 131 |     |         // refund user if they paid too much
 132 |     |         if (baseSurplus > 0) {
 133 |     |             IERC20(info.baseToken).safeTransfer(recipient, baseSurplus);
 134 |     |         }
 135 |     | 
 136 |     |         (tokenAmount, needsMigration) = (tokenAmountBuy, exceeded);
 137 |     |     }
 138 |     | 
 139 |     |     /**
 140 |     |      * @notice Sell tokens to the bonding curve for base token
 141 |     |      * @param token The token address
 142 |     |      * @param tokenAmount The amount of tokens to sell
 143 |     |      * @param minAmountOut The minimum amount of base tokens to receive
 144 |     |      * @param recipient The address to send the base tokens to
 145 |     |      * @param info The token info struct
 146 |     |      * @param unwrap True if the base token should be unwrapped (only if base token in WBera)
 147 |     |      * @return netBaseAmount The amount of base tokens after fees
 148 |     |      */
 149 |     |     function _sell(
 150 |     |         address token,
 151 |     |         uint256 tokenAmount,
 152 |     |         uint256 minAmountOut,
 153 |     |         address recipient,
 154 |     |         TokenInfo storage info,
 155 |     |         bool unwrap
 156 |     |     ) internal override returns (uint256 netBaseAmount) {
 157 |     |         address baseToken = info.baseToken;
 158 |     |         uint256 baseBalance = info.baseBalance;
 159 |     |         uint256 baseAmountSell = _calculateSellPrice(
 160 |     |             tokenAmount,
 161 |     |             info.tokenBalance,
 162 |     |             info.baseBalance,
 163 |     |             info.k
 164 |     |         );
 165 |     | 
 166 |     |         if (baseBalance - info.initialBase < baseAmountSell)
 167 |     |             revert BuzzVault_InvalidReserves();
 168 |     |         if (baseAmountSell < minAmountOut) revert BuzzVault_SlippageExceeded();
 169 |     |         if (baseAmountSell == 0) revert BuzzVault_QuoteAmountZero();
 170 |     | 
 171 |     |         // Update balances
 172 |     |         info.baseBalance -= baseAmountSell;
 173 |     |         info.tokenBalance += tokenAmount;
 174 |     | 
 175 |     |         uint256 tradingFee = FEE_MANAGER.quoteTradingFee(baseAmountSell);
 176 |     | 
 177 |     |         netBaseAmount = baseAmountSell - tradingFee;
 178 |     | 
 179 |     |         // Collect trading and referral fee
 180 |     |         _collectFees(baseToken, msg.sender, baseAmountSell);
 181 |     | 
 182 |     |         IERC20(token).safeTransferFrom(msg.sender, address(this), tokenAmount);
 183 |     | 
 184 |     |         if (unwrap && baseToken == address(WBERA)) {
 185 |     |             _unwrap(recipient, netBaseAmount);
 186 |     |         } else {
 187 |     |             IERC20(baseToken).safeTransfer(recipient, netBaseAmount);
 188 |     |         }
 189 |     |     }
 190 |     | 
 191 |     |     /**
 192 |     |      * @notice Calculate the amount of quote tokens that can be bought at the current curve
 193 |     |      * @param baseAmountIn The amount of base tokens to buy with
 194 |     |      * @param baseBalance The virtual base token balance in the curve
 195 |     |      * @param quoteBalance The virtual quote token balance in the curve
 196 |     |      * @param k The k coefficient of the curve
 197 |     |      * @return amountOut The amount of quote tokens that will be bought
 198 |     |      */
 199 |     |     function _calculateBuyPrice(
 200 |     |         uint256 baseAmountIn,
 201 |     |         uint256 baseBalance,
 202 |     |         uint256 quoteBalance,
 203 |     |         uint256 quoteThreshold,
 204 |     |         uint256 k
 205 |     |     ) internal pure returns (uint256 amountOut, bool exceeded) {
 206 |     |         uint256 amountAux = quoteBalance - k / (baseBalance + baseAmountIn);
 207 |     |         exceeded = amountAux >= quoteBalance - quoteThreshold;
 208 |     |         amountOut = exceeded ? quoteBalance - quoteThreshold : amountAux;
 209 |     |     }
 210 |     | 
 211 |     |     /**
 212 |     |      * @notice Calculate the amount of base tokens that can be received for selling quote tokens
 213 |     |      * @param quoteAmountIn The amount of quote tokens to sell
 214 |     |      * @param quoteBalance The virtual quote token balance in the curve
 215 |     |      * @param baseBalance The virtual base token balance in the curve
 216 |     |      * @param k The k coefficient of the curve
 217 |     |      * @return amountOut The amount of base tokens that will be received
 218 |     |      */
 219 |     |     function _calculateSellPrice(
 220 |     |         uint256 quoteAmountIn,
 221 |     |         uint256 quoteBalance,
 222 |     |         uint256 baseBalance,
 223 |     |         uint256 k
 224 |     |     ) internal pure returns (uint256 amountOut) {
 225 |     |         amountOut = baseBalance - k / (quoteBalance + quoteAmountIn);
 226 |     |     }
 227 |     | 
 228 |     |     /**
 229 |     |      * @notice Collect trading and referral fees
 230 |     |      * @param token The token address
 231 |     |      * @param user The user address
 232 |     |      * @param amount The amount of tokens to collect fees from
 233 |     |      * @return tradingFee The trading fee collected
 234 |     |      * @return referralFee The referral fee collected
 235 |     |      */
 236 |     |     function _collectFees(
 237 |     |         address token,
 238 |     |         address user,
 239 |     |         uint256 amount
 240 |     |     ) internal returns (uint256 tradingFee, uint256 referralFee) {
 241 |     |         tradingFee = FEE_MANAGER.quoteTradingFee(amount);
 242 |     |         if (tradingFee > 0) {
 243 |     |             referralFee = REFERRAL_MANAGER.quoteReferralFee(user, tradingFee);
 244 |     |             // will never underflow because ref fee is a % of trading fee
 245 |     |             uint256 tradingMinusRef = tradingFee - referralFee;
 246 |     | 
 247 |     |             IERC20(token).safeApprove(address(FEE_MANAGER), tradingMinusRef);
 248 |     |             FEE_MANAGER.collectTradingFee(token, tradingMinusRef);
 249 |     |             _collectReferralFee(user, token, tradingFee);
 250 |     |         }
 251 |     |     }
 252 |     | }
 253 |     | 

/mnt/c/Users/zerox/repos/bera.buzz-contracts/contracts/FeeManager.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity ^0.8.19;
   3 |     | 
   4 |     | import {SafeERC20, IERC20} from "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
   5 |     | import {Ownable} from "@openzeppelin/contracts/access/Ownable.sol";
   6 |     | import {IFeeManager} from "./interfaces/IFeeManager.sol";
   7 |     | 
   8 |     | /**
   9 |     |  * @title FeeManager
  10 |     |  * @notice This contract collects and forwards to the treasury the different types of fees in the protocol
  11 |     |  * @author nexusflip, 0xMitzie
  12 |     |  */
  13 | *   | contract FeeManager is Ownable, IFeeManager {
  14 |     |     using SafeERC20 for IERC20;
  15 |     | 
  16 |     |     /// @notice Event emitted when an ERC20 fee is received
  17 |     |     event FeeReceived(address indexed token, uint256 amount);
  18 |     |     /// @notice Event emitted when a native currency fee is received
  19 |     |     event NativeFeeReceived(uint256 amount);
  20 |     |     /// @notice Event emitted when the treasury address is set
  21 |     |     event TreasurySet(address indexed treasury);
  22 |     |     /// @notice Event emitted when the trading fee is set
  23 |     |     event TradingFeeSet(uint256 tradingFeeBps);
  24 |     |     /// @notice Event emitted when the listing fee is set
  25 |     |     event ListingFeeSet(uint256 listingFee);
  26 |     |     /// @notice Event emitted when the migration fee is set
  27 |     |     event MigrationFeeSet(uint256 migrationFeeBps);
  28 |     | 
  29 |     |     /// @notice Error thrown when treasury is the zero address
  30 |     |     error FeeManager_TreasuryAddressZero();
  31 |     |     /// @notice Error thrown when the amount is above the fee divisor
  32 |     |     error FeeManager_AmountAboveFeeDivisor();
  33 |     |     /// @notice Error thrown when the fee is insufficient
  34 |     |     error FeeManager_InsufficientFee();
  35 |     | 
  36 |     |     /// @notice The divisor used to calculate fees (one percent equals 100)
  37 | *   |     uint256 public constant FEE_DIVISOR = 1e4;
  38 |     |     /// @notice The trading fee in basis points. (one percent equals 100)
  39 |     |     uint256 public tradingFeeBps;
  40 |     |     /// @notice The AMM migration fee in basis points. (one percent equals 100)
  41 |     |     uint256 public migrationFeeBps;
  42 |     |     /// @notice The fixed listing fee amount in the native token that needs to be collected
  43 | *   |     uint256 public listingFee;
  44 |     |     /// @notice The treasury address where fees are sent
  45 |     |     address public treasury;
  46 |     | 
  47 |     |     /**
  48 |     |      * @notice Constructor
  49 |     |      * @param _treasury The treasury address where fees are sent
  50 |     |      * @param _tradingFeeBps The trading fee in basis points (one percent equals 100)
  51 |     |      * @param _listingFee The listing fee amount in wei (in the native token)
  52 |     |      * @param _migrationFeeBps The AMM migration fee in basis points (one percent equals 100)
  53 |     |      */
  54 | *   |     constructor(
  55 |     |         address _treasury,
  56 |     |         uint256 _tradingFeeBps,
  57 |     |         uint256 _listingFee,
  58 |     |         uint256 _migrationFeeBps
  59 |     |     ) {
  60 | *   |         if ((_tradingFeeBps > FEE_DIVISOR) || (_migrationFeeBps > FEE_DIVISOR))
  61 |     |             revert FeeManager_AmountAboveFeeDivisor();
  62 |     | 
  63 | *   |         treasury = _treasury;
  64 | *   |         tradingFeeBps = _tradingFeeBps;
  65 | *   |         listingFee = _listingFee;
  66 | *   |         migrationFeeBps = _migrationFeeBps;
  67 |     | 
  68 | *   |         emit TreasurySet(_treasury);
  69 | *   |         emit TradingFeeSet(_tradingFeeBps);
  70 | *   |         emit ListingFeeSet(_listingFee);
  71 | *   |         emit MigrationFeeSet(_migrationFeeBps);
  72 |     |     }
  73 |     | 
  74 |     |     /**
  75 |     |      * @notice Collects the trading fee from the sender. Fee should be quoted before calling this function
  76 |     |      * @dev Approval needs to be given to this contract prior to calling this function
  77 |     |      * @param token The token address
  78 |     |      * @param amount The net fee amount to collect
  79 |     |      */
  80 |     |     function collectTradingFee(address token, uint256 amount) external {
  81 |     |         _collect(token, amount);
  82 |     |     }
  83 |     | 
  84 |     |     /**
  85 |     |      * @notice Collects the listing fee in native currency from the sender
  86 |     |      */
  87 | *   |     function collectListingFee() external payable {
  88 | *   |         uint256 listing = listingFee;
  89 | *   |         if (listing > 0) {
  90 | *   |             if (msg.value != listing) revert FeeManager_InsufficientFee();
  91 | *   |             (bool success, ) = treasury.call{value: listing}("");
  92 | *   |             if (!success) revert FeeManager_InsufficientFee();
  93 | *   |             emit NativeFeeReceived(listing);
  94 |     |         }
  95 |     |     }
  96 |     | 
  97 |     |     /**
  98 |     |      * @notice Collects the AMM migration fee from the sender
  99 |     |      * @dev Approval needs to be given to this contract prior to calling this function
 100 |     |      * @param token The token address
 101 |     |      * @param amount The amount to calculate the fee on
 102 |     |      */
 103 |     |     function collectMigrationFee(address token, uint256 amount) external {
 104 |     |         uint256 fee = quoteMigrationFee(amount);
 105 |     |         if (fee > 0) _collect(token, fee);
 106 |     |     }
 107 |     | 
 108 |     |     /**
 109 |     |      * @notice Quotes the dynamic trading fee for a given amount
 110 |     |      * @dev External contracts should quote the fee to give an approval before calling collect
 111 |     |      * @param amount The amount to quote
 112 |     |      * @return fee The fee amount
 113 |     |      */
 114 |     |     function quoteTradingFee(
 115 |     |         uint256 amount
 116 |     |     ) external view returns (uint256 fee) {
 117 |     |         fee = (amount * tradingFeeBps) / FEE_DIVISOR;
 118 |     |     }
 119 |     | 
 120 |     |     /**
 121 |     |      * @notice Quotes the migration fee
 122 |     |      * @dev External contracts should quote the fee to give an approval before calling collect
 123 |     |      * @param amount The amount to quote
 124 |     |      * @return fee The fee amount
 125 |     |      */
 126 |     |     function quoteMigrationFee(
 127 |     |         uint256 amount
 128 |     |     ) public view returns (uint256 fee) {
 129 |     |         fee = (amount * migrationFeeBps) / FEE_DIVISOR;
 130 |     |     }
 131 |     | 
 132 |     |     // Admin functions
 133 |     | 
 134 |     |     /**
 135 |     |      * @notice Sets the trading fee basis points
 136 |     |      * @dev Only the owner can call this function
 137 |     |      * @param feeBps_ The trading fee in basis points (one percent equals 100)
 138 |     |      */
 139 |     |     function setTradingFeeBps(uint256 feeBps_) external onlyOwner {
 140 |     |         if (feeBps_ > FEE_DIVISOR) revert FeeManager_AmountAboveFeeDivisor();
 141 |     | 
 142 |     |         tradingFeeBps = feeBps_;
 143 |     |         emit TradingFeeSet(feeBps_);
 144 |     |     }
 145 |     | 
 146 |     |     /**
 147 |     |      * @notice Sets the listing fee amount in the native currency
 148 |     |      * @dev Only the owner can call this function
 149 |     |      * @param listingFee_ The listing fee amount
 150 |     |      */
 151 |     |     function setListingFee(uint256 listingFee_) external onlyOwner {
 152 |     |         listingFee = listingFee_;
 153 |     |         emit ListingFeeSet(listingFee_);
 154 |     |     }
 155 |     | 
 156 |     |     /**
 157 |     |      * @notice Sets the AMM migration fee basis points
 158 |     |      * @dev Only the owner can call this function
 159 |     |      * @param feeBps_ The migration fee in basis points (one percent equals 100)
 160 |     |      */
 161 |     |     function setMigrationFeeBps(uint256 feeBps_) external onlyOwner {
 162 |     |         if (feeBps_ > FEE_DIVISOR) revert FeeManager_AmountAboveFeeDivisor();
 163 |     | 
 164 |     |         migrationFeeBps = feeBps_;
 165 |     |         emit MigrationFeeSet(feeBps_);
 166 |     |     }
 167 |     | 
 168 |     |     /**
 169 |     |      * @notice Sets the treasury address
 170 |     |      * @dev Only the owner can call this function
 171 |     |      * @param treasury_ The treasury address where fees are sent
 172 |     |      */
 173 |     |     function setTreasury(address treasury_) external onlyOwner {
 174 |     |         if (treasury_ == address(0)) revert FeeManager_TreasuryAddressZero();
 175 |     | 
 176 |     |         treasury = treasury_;
 177 |     |         emit TreasurySet(treasury_);
 178 |     |     }
 179 |     | 
 180 |     |     // Internal functions
 181 |     | 
 182 |     |     /**
 183 |     |      * @notice Internal function to collect an ERC20 fee and send it to the treasury
 184 |     |      * @param token The token address
 185 |     |      * @param amount The amount to collect
 186 |     |      */
 187 |     |     function _collect(address token, uint256 amount) internal {
 188 |     |         IERC20(token).safeTransferFrom(_msgSender(), treasury, amount);
 189 |     |         emit FeeReceived(token, amount);
 190 |     |     }
 191 |     | }
 192 |     | 

/mnt/c/Users/zerox/repos/bera.buzz-contracts/contracts/HighlightsManager.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity ^0.8.19;
   3 |     | 
   4 |     | import {Ownable} from "@openzeppelin/contracts/access/Ownable.sol";
   5 |     | import {Pausable} from "@openzeppelin/contracts/security/Pausable.sol";
   6 |     | 
   7 |     | /**
   8 |     |  * @title HighlightsManager
   9 |     |  * @notice This contract manages the highlighting of tokens
  10 |     |  * @author nexusflip, 0xMitzie
  11 |     |  */
  12 | *   | contract HighlightsManager is Ownable, Pausable {
  13 |     |     /// @notice Event emitted when a token is highlighted
  14 |     |     event TokenHighlighted(
  15 |     |         address indexed token,
  16 |     |         address indexed buyer,
  17 |     |         uint256 duration,
  18 |     |         uint256 bookedUntil,
  19 |     |         uint256 fee
  20 |     |     );
  21 |     |     /// @notice Event emitted when the treasury address is set
  22 |     |     event TreasurySet(address indexed treasury);
  23 |     |     /// @notice Event emitted when the base fee is set
  24 |     |     event BaseFeeSet(uint256 baseFeePerSecond);
  25 |     |     /// @notice Event emitted when the hard cap is set
  26 |     |     event HardCapSet(uint256 hardCap);
  27 |     |     /// @notice Event emitted when the cool down period is set
  28 |     |     event CoolDownPeriodSet(uint256 coolDownPeriod);
  29 |     | 
  30 |     |     /// @notice Error thrown when the duration is zero
  31 |     |     error HighlightsManager_ZeroDuration();
  32 |     |     /// @notice Error thrown when the duration is above the hard cap
  33 |     |     error HighlightsManager_DurationExceedsHardCap();
  34 |     |     /// @notice Error thrown when the duration is below the MIN_DURATION
  35 |     |     error HighlightsManager_DurationBelowMinimum();
  36 |     |     /// @notice Error thrown when the fee is insufficient
  37 |     |     error HighlightsManager_InsufficientFee();
  38 |     |     /// @notice Error thrown when the hard cap is below the MIN_DURATION
  39 |     |     error HighlightsManager_HardCapBelowMinimumDuration();
  40 |     |     /// @notice Error thrown when the treasury is the zero address
  41 |     |     error HighlightsManager_TreasuryAddressZero();
  42 |     |     /// @notice Error thrown when the transfer in native currency fails
  43 |     |     error HighlightsManager_EthTransferFailed();
  44 |     |     /// @notice Error thrown when the slot is already occupied
  45 |     |     error HighlightsManager_SlotOccupied();
  46 |     |     /// @notice Error thrown when the token is within the cool down period
  47 |     |     error HighlightsManager_TokenWithinCoolDown();
  48 |     | 
  49 |     |     /// @notice The minimum duration allowed in seconds
  50 | *   |     uint256 public constant MIN_DURATION = 60; // 60 = 1 minute
  51 |     |     /// @notice The threshold after which the fee increases exponentially
  52 | *   |     uint256 public constant EXP_THRESHOLD = 600; // 600 = 10 minutes
  53 |     |     /// @notice Growth rate for 50x fee on 1 hour vs 10 minutes
  54 | *   |     uint256 public constant GROWTH_FACTOR = 98;
  55 |     |     /// @notice The maximum duration allowed in seconds
  56 |     |     uint256 public hardCap;
  57 |     |     /// @notice The cool down period for a token in seconds
  58 |     |     uint256 public coolDownPeriod;
  59 |     |     /// @notice The base fee per second to charge in wei
  60 |     |     uint256 public baseFeePerSecond;
  61 |     |     /// @notice The timestamp when the latest highlight expires
  62 | *   |     uint256 public bookedUntil;
  63 |     |     /// @notice The treasury address where fees are sent
  64 |     |     address payable public treasury;
  65 |     | 
  66 |     |     /// @notice The timestamp when a token can be highlighted again
  67 | *   |     mapping(address => uint256) public tokenCoolDownUntil;
  68 |     | 
  69 |     |     /**
  70 |     |      * @notice Constructor
  71 |     |      * @param _treasury The treasury address where fees are sent
  72 |     |      * @param _hardCap The maximum duration allowed in seconds
  73 |     |      * @param _baseFeePerSecond The base fee per second to charge in wei
  74 |     |      */
  75 | *   |     constructor(
  76 |     |         address payable _treasury,
  77 |     |         uint256 _hardCap,
  78 |     |         uint256 _baseFeePerSecond,
  79 |     |         uint256 _coolDownPeriod
  80 |     |     ) {
  81 | *   |         if (_hardCap < MIN_DURATION)
  82 |     |             revert HighlightsManager_HardCapBelowMinimumDuration();
  83 |     | 
  84 | *   |         treasury = _treasury;
  85 | *   |         hardCap = _hardCap;
  86 | *   |         baseFeePerSecond = _baseFeePerSecond;
  87 | *   |         coolDownPeriod = _coolDownPeriod;
  88 |     | 
  89 | *   |         emit TreasurySet(_treasury);
  90 | *   |         emit HardCapSet(_hardCap);
  91 | *   |         emit BaseFeeSet(_baseFeePerSecond);
  92 | *   |         emit CoolDownPeriodSet(_coolDownPeriod);
  93 |     |     }
  94 |     | 
  95 |     |     /**
  96 |     |      * @notice Allows msg.sender to highlights a token for a given duration, paying the fee in native currency
  97 |     |      * @dev BookedUntil must be in the past to allow a new highlight.
  98 |     |      * @param token The address of the token to highlight
  99 |     |      * @param duration The duration in seconds
 100 |     |      */
 101 |     |     function highlightToken(
 102 |     |         address token,
 103 |     |         uint256 duration
 104 |     |     ) external payable whenNotPaused {
 105 |     |         if (bookedUntil > block.timestamp)
 106 |     |             revert HighlightsManager_SlotOccupied();
 107 |     |         if (tokenCoolDownUntil[token] > block.timestamp)
 108 |     |             revert HighlightsManager_TokenWithinCoolDown();
 109 |     | 
 110 |     |         uint256 fee = quote(duration);
 111 |     |         if (msg.value != fee) revert HighlightsManager_InsufficientFee();
 112 |     | 
 113 |     |         bookedUntil = block.timestamp + duration;
 114 |     |         tokenCoolDownUntil[token] = block.timestamp + coolDownPeriod;
 115 |     |         
 116 |     |         (bool success, ) = treasury.call{value: fee}("");
 117 |     |         if (!success) revert HighlightsManager_EthTransferFailed();
 118 |     | 
 119 |     |         emit TokenHighlighted(token, msg.sender, duration, bookedUntil, fee);
 120 |     |     }
 121 |     | 
 122 |     |     /**
 123 |     |      * @notice Sets the treasury address
 124 |     |      * @dev Only the owner can call this function
 125 |     |      * @param treasury_ The treasury address where fees are sent
 126 |     |      */
 127 |     |     function setTreasury(address payable treasury_) external onlyOwner {
 128 |     |         if (treasury_ == address(0))
 129 |     |             revert HighlightsManager_TreasuryAddressZero();
 130 |     | 
 131 |     |         treasury = treasury_;
 132 |     |         emit TreasurySet(treasury_);
 133 |     |     }
 134 |     | 
 135 |     |     /**
 136 |     |      * @notice Sets the hard cap for the duration
 137 |     |      * @dev Only the owner can call this function
 138 |     |      * @param hardCap_ The maximum duration allowed in seconds
 139 |     |      */
 140 |     |     function setHardCap(uint256 hardCap_) external onlyOwner {
 141 |     |         if (hardCap_ < MIN_DURATION)
 142 |     |             revert HighlightsManager_HardCapBelowMinimumDuration();
 143 |     | 
 144 |     |         hardCap = hardCap_;
 145 |     |         emit HardCapSet(hardCap_);
 146 |     |     }
 147 |     | 
 148 |     |     /**
 149 |     |      * @notice Sets the base fee per second
 150 |     |      * @dev Only the owner can call this function
 151 |     |      * @param baseFeePerSecond_ The base fee per second to charge in wei
 152 |     |      */
 153 |     |     function setBaseFee(uint256 baseFeePerSecond_) external onlyOwner {
 154 |     |         baseFeePerSecond = baseFeePerSecond_;
 155 |     |         emit BaseFeeSet(baseFeePerSecond_);
 156 |     |     }
 157 |     | 
 158 |     |     /**
 159 |     |      * @notice Sets the cool down period for a token
 160 |     |      * @dev Only the owner can call this function
 161 |     |      * @param coolDownPeriod_ The cool down period in seconds
 162 |     |      */
 163 |     |     function setCoolDownPeriod(uint256 coolDownPeriod_) external onlyOwner {
 164 |     |         coolDownPeriod = coolDownPeriod_;
 165 |     |         emit CoolDownPeriodSet(coolDownPeriod_);
 166 |     |     }
 167 |     | 
 168 |     |     /**
 169 |     |      * @notice Pauses the contract
 170 |     |      * @dev Only the owner can call this function.
 171 |     |      */
 172 |     |     function pause() external onlyOwner {
 173 |     |         _pause();
 174 |     |     }
 175 |     | 
 176 |     |     /**
 177 |     |      * @notice Unpauses the contract
 178 |     |      * @dev Only the owner can call this function.
 179 |     |      */
 180 |     |     function unpause() external onlyOwner {
 181 |     |         _unpause();
 182 |     |     }
 183 |     | 
 184 |     |     /**
 185 |     |      * @notice Quotes the fee for highlighting a token for a given duration
 186 |     |      * @param duration The duration in seconds
 187 |     |      * @return fee The fee in wei
 188 |     |      */
 189 | *   |     function quote(uint256 duration) public view returns (uint256 fee) {
 190 | *   |         uint256 expThreshold = EXP_THRESHOLD;
 191 | *   |         uint256 baseFeePs = baseFeePerSecond;
 192 |     | 
 193 | *   |         if (duration == 0) revert HighlightsManager_ZeroDuration();
 194 | *   |         if (duration < MIN_DURATION)
 195 |     |             revert HighlightsManager_DurationBelowMinimum();
 196 | *   |         if (duration > hardCap)
 197 |     |             revert HighlightsManager_DurationExceedsHardCap();
 198 | *   |         if (duration <= expThreshold) {
 199 | *   |             fee = baseFeePs * duration;
 200 | *   |         } else {
 201 | *   |             uint256 extraTime = duration - expThreshold;
 202 |     | 
 203 |     |             // Calculate exponential fee using the growth factor
 204 | *   |             uint256 exponentialFee = (baseFeePs * extraTime * GROWTH_FACTOR) /
 205 | *   |                 10;
 206 |     | 
 207 |     |             // Total fee is the sum of the base fee and the exponential component
 208 | *   |             fee = (baseFeePs * expThreshold) + exponentialFee;
 209 |     |         }
 210 | *   |         return fee;
 211 |     |     }
 212 |     | }
 213 |     | 

/mnt/c/Users/zerox/repos/bera.buzz-contracts/contracts/ReferralManager.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity ^0.8.19;
   3 |     | 
   4 |     | import {SafeERC20, IERC20} from "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
   5 |     | import {Ownable} from "@openzeppelin/contracts/access/Ownable.sol";
   6 |     | import {IReferralManager} from "./interfaces/IReferralManager.sol";
   7 |     | 
   8 |     | /**
   9 |     |  * @title ReferralManager
  10 |     |  * @notice This contract manages the referral system for the protocol
  11 |     |  * @author nexusflip, 0xMitzie
  12 |     |  */
  13 | *   | contract ReferralManager is Ownable, IReferralManager {
  14 |     |     using SafeERC20 for IERC20;
  15 |     | 
  16 |     |     /// @notice Event emitted when a referral is set
  17 |     |     event ReferralSet(address indexed referrer, address indexed referredUser);
  18 |     |     /// @notice Event emitted when an indirect referral is set
  19 |     |     event IndirectReferralSet(
  20 |     |         address indexed indirectReferrer,
  21 |     |         address indexed referredUser,
  22 |     |         address indexed directReferrer
  23 |     |     );
  24 |     |     /// @notice Event emitted when a referral reward is received
  25 |     |     event ReferralRewardReceived(
  26 |     |         address indexed referrer,
  27 |     |         address indexed token,
  28 |     |         uint256 reward,
  29 |     |         bool isDirect
  30 |     |     );
  31 |     |     /// @notice Event emitted when a referral reward is paid out
  32 |     |     event ReferralPaidOut(
  33 |     |         address indexed referrer,
  34 |     |         address indexed token,
  35 |     |         uint256 reward
  36 |     |     );
  37 |     |     /// @notice Event emitted when the direct referral fee is set
  38 |     |     event DirectRefFeeBpsSet(uint256 directRefFeeBps);
  39 |     |     /// @notice Event emitted when the indirect referral fee is set
  40 |     |     event IndirectRefFeeBpsSet(uint256 indirectRefFeeBps);
  41 |     |     /// @notice Event emitted when the referral deadline is set
  42 |     |     event ReferralDeadlineSet(uint256 validUntil);
  43 |     |     /// @notice Event emitted when the payout threshold is set
  44 |     |     event PayoutThresholdSet(address token, uint256 payoutThreshold);
  45 |     |     /// @notice Event emitted when a vault is whitelisted
  46 |     |     event WhitelistedVaultSet(address indexed vault, bool status);
  47 |     | 
  48 |     |     /// @notice Error emitted when the caller is not authorized
  49 |     |     error ReferralManager_Unauthorised();
  50 |     |     /// @notice Error emitted when the payout is zero
  51 |     |     error ReferralManager_ZeroPayout();
  52 |     |     /// @notice Error emitted when the address is zero
  53 |     |     error ReferralManager_AddressZero();
  54 |     |     /// @notice Error emitted when the referral has expired
  55 |     |     error ReferralManager_ReferralExpired();
  56 |     |     /// @notice Error emitted when the referral has expired
  57 |     |     error ReferralManager_RewardTransferFailed();
  58 |     |     /// @notice Error emitted when the payout is below the threshold
  59 |     |     error ReferralManager_PayoutBelowThreshold();
  60 |     |     /// @notice Error emitted when the array lengths do not match
  61 |     |     error ReferralManager_ArrayLengthMismatch();
  62 |     | 
  63 |     |     /// @notice The maximum fee basis points
  64 |     |     uint256 public constant MAX_FEE_BPS = 10000;
  65 |     |     /// @notice The direct referral fee in basis points
  66 |     |     uint256 public directRefFeeBps; // eg 100 -> 1%
  67 |     |     /// @notice The indirect referral fee in basis points
  68 |     |     uint256 public indirectRefFeeBps; // eg 100 -> 1%
  69 |     |     /// @notice The referral deadline
  70 |     |     uint256 public validUntil;
  71 |     | 
  72 |     |     /// @notice Mapping for referred users and respective referrers
  73 |     |     mapping(address => address) public referredBy;
  74 |     |     /// @notice Mapping for indirect referrals
  75 |     |     mapping(address => address) public indirectReferral;
  76 |     |     /// @notice Whether a given vault is whitelisted
  77 |     |     mapping(address => bool) public whitelistedVault;
  78 |     |     /// @notice The payout threshold for a token
  79 |     |     mapping(address => uint256) public payoutThreshold;
  80 |     |     /// @notice Mapping for referrer balances
  81 |     |     mapping(address => mapping(address => uint256)) private _referrerBalances;
  82 |     | 
  83 |     |     /// @notice Fee bps is the % of the protocol fee that the referrer will receive
  84 | *   |     constructor(
  85 |     |         uint256 _directRefFeeBps,
  86 |     |         uint256 _indirectRefFeeBps,
  87 |     |         uint256 _validUntil,
  88 |     |         address[] memory tokens,
  89 |     |         uint256[] memory _payoutThresholds
  90 |     |     ) {
  91 | *   |         directRefFeeBps = _directRefFeeBps;
  92 | *   |         indirectRefFeeBps = _indirectRefFeeBps;
  93 | *   |         validUntil = _validUntil;
  94 |     | 
  95 | *   |         if (tokens.length > 0) {
  96 | *   |             if (tokens.length != _payoutThresholds.length)
  97 |     |                 revert ReferralManager_ArrayLengthMismatch();
  98 |     | 
  99 | *   |             for (uint256 i = 0; i < tokens.length; ) {
 100 | *   |                 payoutThreshold[tokens[i]] = _payoutThresholds[i];
 101 | *   |                 emit PayoutThresholdSet(tokens[i], _payoutThresholds[i]);
 102 |     | 
 103 |     |                 unchecked {
 104 | *   |                     ++i;
 105 |     |                 }
 106 |     |             }
 107 |     |         }
 108 |     | 
 109 | *   |         emit DirectRefFeeBpsSet(_directRefFeeBps);
 110 | *   |         emit IndirectRefFeeBpsSet(_indirectRefFeeBps);
 111 | *   |         emit ReferralDeadlineSet(_validUntil);
 112 |     |     }
 113 |     | 
 114 |     |     // Vault functions
 115 |     | 
 116 |     |     /// @notice Callable by the vault with the address of the referred user
 117 |     |     function receiveReferral(
 118 |     |         address user,
 119 |     |         address token,
 120 |     |         uint256 amount
 121 |     |     ) external {
 122 |     |         if (!whitelistedVault[msg.sender])
 123 |     |             revert ReferralManager_Unauthorised();
 124 |     |         address referrer = referredBy[user];
 125 |     | 
 126 |     |         if (validUntil < block.timestamp)
 127 |     |             revert ReferralManager_ReferralExpired();
 128 |     |         if (referrer == address(0)) revert ReferralManager_AddressZero();
 129 |     |         if (amount == 0) revert ReferralManager_ZeroPayout();
 130 |     | 
 131 |     |         if (indirectReferral[user] != address(0)) {
 132 |     |             // If there is an indirect referral
 133 |     |             uint256 indirectReferralAmount = (amount * indirectRefFeeBps) /
 134 |     |                 MAX_FEE_BPS;
 135 |     |             _referrerBalances[indirectReferral[user]][
 136 |     |                 token
 137 |     |             ] += indirectReferralAmount;
 138 |     |             emit ReferralRewardReceived(
 139 |     |                 indirectReferral[user],
 140 |     |                 token,
 141 |     |                 indirectReferralAmount,
 142 |     |                 false
 143 |     |             );
 144 |     | 
 145 |     |             uint256 directReferralAmount = amount - indirectReferralAmount;
 146 |     |             _referrerBalances[referrer][token] += directReferralAmount;
 147 |     |             emit ReferralRewardReceived(
 148 |     |                 referrer,
 149 |     |                 token,
 150 |     |                 directReferralAmount,
 151 |     |                 true
 152 |     |             );
 153 |     |         } else {
 154 |     |             _referrerBalances[referrer][token] += amount;
 155 |     |             emit ReferralRewardReceived(referrer, token, amount, true);
 156 |     |         }
 157 |     | 
 158 |     |         IERC20(token).safeTransferFrom(msg.sender, address(this), amount);
 159 |     |     }
 160 |     | 
 161 |     |     /**
 162 |     |      * @notice Callable by the vault to set the referral for a user
 163 |     |      * @param referrer The address of the referrer
 164 |     |      * @param user The address of the referred user
 165 |     |      */
 166 |     |     function setReferral(address referrer, address user) external {
 167 |     |         if (!whitelistedVault[msg.sender])
 168 |     |             revert ReferralManager_Unauthorised();
 169 |     | 
 170 |     |         if (
 171 |     |             (referredBy[user] != address(0)) ||
 172 |     |             (referrer == user) ||
 173 |     |             (referrer == address(0))
 174 |     |         ) {
 175 |     |             return;
 176 |     |         }
 177 |     | 
 178 |     |         referredBy[user] = referrer;
 179 |     |         emit ReferralSet(referrer, user);
 180 |     | 
 181 |     |         address indirectReferrer = referredBy[referrer];
 182 |     |         if (indirectReferrer != address(0)) {
 183 |     |             indirectReferral[user] = indirectReferrer;
 184 |     |             emit IndirectReferralSet(indirectReferrer, user, referrer);
 185 |     |         }
 186 |     |     }
 187 |     | 
 188 |     |     /**
 189 |     |      * @notice Calculates the referral fee for a user
 190 |     |      * @param user The user address
 191 |     |      * @param amount The amount to calculate the fee on
 192 |     |      * @return referralFee The referral fee
 193 |     |      */
 194 |     |     function quoteReferralFee(
 195 |     |         address user,
 196 |     |         uint256 amount
 197 |     |     ) external view returns (uint256 referralFee) {
 198 |     |         uint256 bps = getReferralBpsFor(user);
 199 |     | 
 200 |     |         if (bps > 0) {
 201 |     |             referralFee = (amount * bps) / 1e4;
 202 |     |         }
 203 |     |     }
 204 |     | 
 205 |     |     /**
 206 |     |      * @notice Callable by the vault with the address of the referred user
 207 |     |      * @param user The address of the referred user
 208 |     |      * @return totalReferralBps The total referral bps that the calling contract should deduct from the protocol fee
 209 |     |      */
 210 |     |     function getReferralBpsFor(
 211 |     |         address user
 212 |     |     ) public view returns (uint256 totalReferralBps) {
 213 |     |         if (
 214 |     |             (validUntil < block.timestamp) || (referredBy[user] == address(0))
 215 |     |         ) {
 216 |     |             return 0;
 217 |     |         }
 218 |     | 
 219 |     |         totalReferralBps = directRefFeeBps;
 220 |     |         if (indirectReferral[user] != address(0)) {
 221 |     |             totalReferralBps += indirectRefFeeBps;
 222 |     |         }
 223 |     |     }
 224 |     | 
 225 |     |     // User functions
 226 |     | 
 227 |     |     /**
 228 |     |      * @notice Claims the referral reward for a given base token for the msg.sender
 229 |     |      * @param token The token address
 230 |     |      */
 231 |     |     function claimReferralReward(address token) external {
 232 |     |         if (token == address(0)) revert ReferralManager_AddressZero();
 233 |     |         uint256 reward = _referrerBalances[msg.sender][token];
 234 |     | 
 235 |     |         if (reward < payoutThreshold[token])
 236 |     |             revert ReferralManager_PayoutBelowThreshold();
 237 |     |         if (reward == 0) revert ReferralManager_ZeroPayout();
 238 |     | 
 239 |     |         _referrerBalances[msg.sender][token] = 0;
 240 |     |         IERC20(token).safeTransfer(msg.sender, reward);
 241 |     | 
 242 |     |         emit ReferralPaidOut(msg.sender, token, reward);
 243 |     |     }
 244 |     | 
 245 |     |     // Admin functions
 246 |     | 
 247 |     |     /**
 248 |     |      * @notice Sets the direct referral fee
 249 |     |      * @param directRefFeeBps_ The direct referral fee in basis points
 250 |     |      */
 251 |     |     function setDirectRefFeeBps(uint256 directRefFeeBps_) external onlyOwner {
 252 |     |         directRefFeeBps = directRefFeeBps_;
 253 |     |         emit DirectRefFeeBpsSet(directRefFeeBps);
 254 |     |     }
 255 |     | 
 256 |     |     /**
 257 |     |      * @notice Sets the indirect referral fee
 258 |     |      * @param indirectRefFeeBps_ The indirect referral fee in basis points
 259 |     |      */
 260 |     |     function setIndirectRefFeeBps(
 261 |     |         uint256 indirectRefFeeBps_
 262 |     |     ) external onlyOwner {
 263 |     |         indirectRefFeeBps = indirectRefFeeBps_;
 264 |     |         emit IndirectRefFeeBpsSet(indirectRefFeeBps);
 265 |     |     }
 266 |     | 
 267 |     |     /**
 268 |     |      * @notice Sets the referral deadline
 269 |     |      * @param validUntil_ The referral deadline
 270 |     |      */
 271 |     |     function setValidUntil(uint256 validUntil_) external onlyOwner {
 272 |     |         validUntil = validUntil_;
 273 |     |         emit ReferralDeadlineSet(validUntil);
 274 |     |     }
 275 |     | 
 276 |     |     /**
 277 |     |      * @notice Sets the payout threshold for a token
 278 |     |      * @param tokens The token addresses
 279 |     |      * @param thresholds The payout thresholds
 280 |     |      */
 281 |     |     function setPayoutThreshold(
 282 |     |         address[] calldata tokens,
 283 |     |         uint256[] calldata thresholds
 284 |     |     ) external onlyOwner {
 285 |     |         if (tokens.length != thresholds.length)
 286 |     |             revert ReferralManager_ArrayLengthMismatch();
 287 |     | 
 288 |     |         for (uint256 i; i < tokens.length; ) {
 289 |     |             if (tokens[i] == address(0)) revert ReferralManager_AddressZero();
 290 |     | 
 291 |     |             payoutThreshold[tokens[i]] = thresholds[i];
 292 |     |             emit PayoutThresholdSet(tokens[i], thresholds[i]);
 293 |     | 
 294 |     |             unchecked {
 295 |     |                 ++i;
 296 |     |             }
 297 |     |         }
 298 |     |     }
 299 |     | 
 300 |     |     /**
 301 |     |      * @notice Sets the vault whitelist status
 302 |     |      * @param vault The vault address
 303 |     |      * @param enable The status of the vault
 304 |     |      */
 305 | *   |     function setWhitelistedVault(
 306 |     |         address vault,
 307 |     |         bool enable
 308 |     |     ) external onlyOwner {
 309 | *   |         if (vault == address(0)) revert ReferralManager_AddressZero();
 310 |     | 
 311 | *   |         whitelistedVault[vault] = enable;
 312 | *   |         emit WhitelistedVaultSet(vault, enable);
 313 |     |     }
 314 |     | 
 315 |     |     /**
 316 |     |      * @notice Gets the referral reward for a user
 317 |     |      * @param user The user address
 318 |     |      * @param token The token address
 319 |     |      * @return reward The reward amount
 320 |     |      */
 321 |     |     function getReferralRewardFor(
 322 |     |         address user,
 323 |     |         address token
 324 |     |     ) external view returns (uint256 reward) {
 325 |     |         reward = _referrerBalances[user][token];
 326 |     |     }
 327 |     | }
 328 |     | 

/mnt/c/Users/zerox/repos/bera.buzz-contracts/contracts/interfaces/IBexLiquidityManager.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.19;
  3 |     | 
  4 |     | interface IBexLiquidityManager {
  5 |     |     function createPoolAndAdd(
  6 |     |         address token,
  7 |     |         address baseToken,
  8 |     |         uint256 baseAmount,
  9 |     |         uint256 amount
 10 |     |     ) external;
 11 |     | }
 12 |     | 

/mnt/c/Users/zerox/repos/bera.buzz-contracts/contracts/interfaces/IBuzzToken.sol
 1 |     | // SPDX-License-Identifier: MIT
 2 |     | pragma solidity ^0.8.19;
 3 |     | 
 4 |     | interface IBuzzToken {
 5 |     |     function mint(address account, uint256 amount) external;
 6 |     |     function totalSupply() external view returns (uint256);
 7 |     | }
 8 |     | 

/mnt/c/Users/zerox/repos/bera.buzz-contracts/contracts/interfaces/IBuzzTokenFactory.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.19;
  3 |     | 
  4 |     | interface IBuzzTokenFactory {
  5 |     |     function createToken(
  6 |     |         string[2] calldata metadata, //name, symbol
  7 |     |         address[2] calldata addr, //baseToken, vault
  8 |     |         uint256[2] calldata raiseData, //initialReserves, finalReserves
  9 |     |         uint256 baseAmount,
 10 |     |         bytes32 salt
 11 |     |     ) external payable returns (address token);
 12 |     | }
 13 |     | 

/mnt/c/Users/zerox/repos/bera.buzz-contracts/contracts/interfaces/IBuzzVault.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.19;
  3 |     | 
  4 |     | interface IBuzzVault {
  5 |     |     function buy(
  6 |     |         address token,
  7 |     |         uint256 baseAmount,
  8 |     |         uint256 minTokensOut,
  9 |     |         address affiliate,
 10 |     |         address recipient
 11 |     |     ) external;
 12 |     | 
 13 |     |     function buyNative(
 14 |     |         address token,
 15 |     |         uint256 minTokensOut,
 16 |     |         address affiliate,
 17 |     |         address recipient
 18 |     |     ) external payable;
 19 |     | 
 20 |     |     function sell(
 21 |     |         address token,
 22 |     |         uint256 tokenAmount,
 23 |     |         uint256 minAmountOut,
 24 |     |         address affiliate,
 25 |     |         address recipient,
 26 |     |         bool unwrap
 27 |     |     ) external;
 28 |     | 
 29 |     |     function registerToken(
 30 |     |         address token,
 31 |     |         address baseToken,
 32 |     |         uint256 initialTokenBalance,
 33 |     |         uint256 initialReserves,
 34 |     |         uint256 finalReserves
 35 |     |     ) external;
 36 |     | 
 37 |     |     function quote(
 38 |     |         address token,
 39 |     |         uint256 amount,
 40 |     |         bool isBuyOrder
 41 |     |     ) external view returns (uint256 amountOut);
 42 |     | }
 43 |     | 

/mnt/c/Users/zerox/repos/bera.buzz-contracts/contracts/interfaces/IFeeManager.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.19;
  3 |     | 
  4 |     | interface IFeeManager {
  5 |     |     function listingFee() external view returns (uint256);
  6 |     | 
  7 |     |     function collectListingFee() external payable;
  8 |     | 
  9 |     |     function collectTradingFee(address token, uint256 amount) external;
 10 |     | 
 11 |     |     function collectMigrationFee(address token, uint256 amount) external;
 12 |     | 
 13 |     |     function quoteTradingFee(
 14 |     |         uint256 amount
 15 |     |     ) external view returns (uint256 fee);
 16 |     | 
 17 |     |     function quoteMigrationFee(
 18 |     |         uint256 amount
 19 |     |     ) external view returns (uint256 fee);
 20 |     | 
 21 |     |     function migrationFeeBps() external view returns (uint256);
 22 |     | }
 23 |     | 

/mnt/c/Users/zerox/repos/bera.buzz-contracts/contracts/interfaces/IReferralManager.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.19;
  3 |     | 
  4 |     | interface IReferralManager {
  5 |     |     function setReferral(address referrer, address user) external;
  6 |     | 
  7 |     |     function getReferralBpsFor(
  8 |     |         address user
  9 |     |     ) external view returns (uint256 bps);
 10 |     | 
 11 |     |     function quoteReferralFee(
 12 |     |         address user,
 13 |     |         uint256 amount
 14 |     |     ) external view returns (uint256 referralFee);
 15 |     | 
 16 |     |     function receiveReferral(
 17 |     |         address user,
 18 |     |         address token,
 19 |     |         uint256 amount
 20 |     |     ) external;
 21 |     | }
 22 |     | 

/mnt/c/Users/zerox/repos/bera.buzz-contracts/contracts/interfaces/IWBera.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.4;
  3 |     | 
  4 |     | interface IWBera {
  5 |     |     function deposit() external payable;
  6 |     | 
  7 |     |     function transfer(address to, uint value) external returns (bool);
  8 |     | 
  9 |     |     function withdraw(uint) external;
 10 |     | 
 11 |     |     function approve(address spender, uint value) external returns (bool);
 12 |     | 
 13 |     |     function balanceOf(address) external view returns (uint256);
 14 |     | }
 15 |     | 

/mnt/c/Users/zerox/repos/bera.buzz-contracts/contracts/interfaces/create3/ICREATE3Factory.sol
  1 |     | // SPDX-License-Identifier: AGPL-3.0
  2 |     | pragma solidity >=0.6.0; // solhint-disable-line
  3 |     | 
  4 |     | /// @title Factory for deploying contracts to deterministic addresses via CREATE3
  5 |     | /// @author zefram.eth
  6 |     | /// @notice Enables deploying contracts using CREATE3. Each deployer (msg.sender) has
  7 |     | /// its own namespace for deployed addresses.
  8 |     | interface ICREATE3Factory {
  9 |     |     /// @notice Deploys a contract using CREATE3
 10 |     |     /// @dev The provided salt is hashed together with msg.sender to generate the final salt
 11 |     |     /// @param salt The deployer-specific salt for determining the deployed contract's address
 12 |     |     /// @param creationCode The creation code of the contract to deploy
 13 |     |     /// @return deployed The address of the deployed contract
 14 |     |     function deploy(
 15 |     |         bytes32 salt,
 16 |     |         bytes memory creationCode
 17 |     |     ) external payable returns (address deployed);
 18 |     | 
 19 |     |     /// @notice Predicts the address of a deployed contract
 20 |     |     /// @dev The provided salt is hashed together with the deployer address to generate the final salt
 21 |     |     /// @param deployer The deployer account that will call deploy()
 22 |     |     /// @param salt The deployer-specific salt for determining the deployed contract's address
 23 |     |     /// @return deployed The address of the contract that will be deployed
 24 |     |     function getDeployed(
 25 |     |         address deployer,
 26 |     |         bytes32 salt
 27 |     |     ) external view returns (address deployed);
 28 |     | }
 29 |     | 

/mnt/c/Users/zerox/repos/bera.buzz-contracts/contracts/libraries/SqrtMath.sol
  1 |     | // SPDX-License-Identifier: GPL2.0
  2 |     | pragma solidity ^0.8.13;
  3 |     | 
  4 |     | uint256 constant Q64_64_PRECISION = 2 ** 64;
  5 |     | 
  6 |     | library SqrtMath {
  7 |     |     // Computes the sqrt of the u64x64 fixed point price given the AMM reserves
  8 |     |     function encodePriceSqrt(
  9 |     |         uint256 reserve1,
 10 |     |         uint256 reserve0
 11 |     |     ) internal pure returns (uint128) {
 12 |     |         require(reserve0 > 0, "Division by zero"); // solhint-disable-line
 13 |     |         return
 14 |     |             uint128(
 15 |     |                 sqrt(
 16 |     |                     (reserve1 * Q64_64_PRECISION * Q64_64_PRECISION) / reserve0
 17 |     |                 )
 18 |     |             );
 19 |     |     }
 20 |     | 
 21 |     |     // Fast sqrt, taken from Solmate.
 22 |     |     function sqrt(uint256 x) internal pure returns (uint256 z) {
 23 |     |         assembly {
 24 |     |             // solhint-disable-line
 25 |     |             // Start off with z at 1.
 26 |     |             z := 1
 27 |     | 
 28 |     |             // Used below to help find a nearby power of 2.
 29 |     |             let y := x
 30 |     | 
 31 |     |             // Find the lowest power of 2 that is at least sqrt(x).
 32 |     |             if iszero(lt(y, 0x100000000000000000000000000000000)) {
 33 |     |                 y := shr(128, y) // Like dividing by 2 ** 128.
 34 |     |                 z := shl(64, z) // Like multiplying by 2 ** 64.
 35 |     |             }
 36 |     |             if iszero(lt(y, 0x10000000000000000)) {
 37 |     |                 y := shr(64, y) // Like dividing by 2 ** 64.
 38 |     |                 z := shl(32, z) // Like multiplying by 2 ** 32.
 39 |     |             }
 40 |     |             if iszero(lt(y, 0x100000000)) {
 41 |     |                 y := shr(32, y) // Like dividing by 2 ** 32.
 42 |     |                 z := shl(16, z) // Like multiplying by 2 ** 16.
 43 |     |             }
 44 |     |             if iszero(lt(y, 0x10000)) {
 45 |     |                 y := shr(16, y) // Like dividing by 2 ** 16.
 46 |     |                 z := shl(8, z) // Like multiplying by 2 ** 8.
 47 |     |             }
 48 |     |             if iszero(lt(y, 0x100)) {
 49 |     |                 y := shr(8, y) // Like dividing by 2 ** 8.
 50 |     |                 z := shl(4, z) // Like multiplying by 2 ** 4.
 51 |     |             }
 52 |     |             if iszero(lt(y, 0x10)) {
 53 |     |                 y := shr(4, y) // Like dividing by 2 ** 4.
 54 |     |                 z := shl(2, z) // Like multiplying by 2 ** 2.
 55 |     |             }
 56 |     |             if iszero(lt(y, 0x8)) {
 57 |     |                 // Equivalent to 2 ** z.
 58 |     |                 z := shl(1, z)
 59 |     |             }
 60 |     | 
 61 |     |             // Shifting right by 1 is like dividing by 2.
 62 |     |             z := shr(1, add(z, div(x, z)))
 63 |     |             z := shr(1, add(z, div(x, z)))
 64 |     |             z := shr(1, add(z, div(x, z)))
 65 |     |             z := shr(1, add(z, div(x, z)))
 66 |     |             z := shr(1, add(z, div(x, z)))
 67 |     |             z := shr(1, add(z, div(x, z)))
 68 |     |             z := shr(1, add(z, div(x, z)))
 69 |     | 
 70 |     |             // Compute a rounded down version of z.
 71 |     |             let zRoundDown := div(x, z)
 72 |     | 
 73 |     |             // If zRoundDown is smaller, use it.
 74 |     |             if lt(zRoundDown, z) {
 75 |     |                 z := zRoundDown
 76 |     |             }
 77 |     |         }
 78 |     |     }
 79 |     | }
 80 |     | 

/mnt/c/Users/zerox/repos/bera.buzz-contracts/contracts/mock/WBERA.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.4;
  3 |     | 
  4 |     | import {WETH} from "solady/src/tokens/WETH.sol";
  5 |     | 
  6 | *   | contract WBERA is WETH {
  7 |     |     /// @dev Returns the name of the token.
  8 |     |     function name() public pure override returns (string memory) {
  9 |     |         return "Wrapped Bera";
 10 |     |     }
 11 |     | 
 12 |     |     /// @dev Returns the symbol of the token.
 13 |     |     function symbol() public pure override returns (string memory) {
 14 |     |         return "WBERA";
 15 |     |     }
 16 |     | }
 17 |     | 

/mnt/c/Users/zerox/repos/bera.buzz-contracts/contracts/mock/create/CREATE3FactoryMock.sol
  1 |     | // SPDX-License-Identifier: AGPL-3.0
  2 |     | pragma solidity ^0.8.13;
  3 |     | 
  4 |     | import {CREATE3} from "solmate/src/utils/CREATE3.sol";
  5 |     | 
  6 |     | import {ICREATE3Factory} from "../../interfaces/create3/ICREATE3Factory.sol";
  7 |     | 
  8 |     | /// @title Factory for deploying contracts to deterministic addresses via CREATE3
  9 |     | /// @author zefram.eth
 10 |     | /// @notice Enables deploying contracts using CREATE3. Each deployer (msg.sender) has
 11 |     | /// its own namespace for deployed addresses.
 12 | *   | contract CREATE3FactoryMock is ICREATE3Factory {
 13 |     |     /// @inheritdoc	ICREATE3Factory
 14 | *   |     function deploy(
 15 |     |         bytes32 salt,
 16 |     |         bytes memory creationCode
 17 | *   |     ) external payable override returns (address deployed) {
 18 |     |         // hash salt with the deployer address to give each deployer its own namespace
 19 | *   |         salt = keccak256(abi.encodePacked(msg.sender, salt));
 20 | *   |         return CREATE3.deploy(salt, creationCode, msg.value);
 21 |     |     }
 22 |     | 
 23 |     |     /// @inheritdoc	ICREATE3Factory
 24 | *   |     function getDeployed(
 25 |     |         address deployer,
 26 |     |         bytes32 salt
 27 | *   |     ) external view override returns (address deployed) {
 28 |     |         // hash salt with the deployer address to give each deployer its own namespace
 29 | *   |         salt = keccak256(abi.encodePacked(deployer, salt));
 30 | *   |         return CREATE3.getDeployed(salt);
 31 |     |     }
 32 |     | }
 33 |     | 

/mnt/c/Users/zerox/repos/bera.buzz-contracts/node_modules/@crytic/properties/contracts/util/Hevm.sol
  1 |     | // SPDX-License-Identifier: Unlicense
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | interface IHevm {
  5 |     |     // Set block.timestamp to newTimestamp
  6 |     |     function warp(uint256 newTimestamp) external;
  7 |     | 
  8 |     |     // Set block.number to newNumber
  9 |     |     function roll(uint256 newNumber) external;
 10 |     | 
 11 |     |     // Add the condition b to the assumption base for the current branch
 12 |     |     // This function is almost identical to require
 13 |     |     function assume(bool b) external;
 14 |     | 
 15 |     |     // Sets the eth balance of usr to amt
 16 |     |     function deal(address usr, uint256 amt) external;
 17 |     | 
 18 |     |     // Loads a storage slot from an address
 19 |     |     function load(address where, bytes32 slot) external returns (bytes32);
 20 |     | 
 21 |     |     // Stores a value to an address' storage slot
 22 |     |     function store(address where, bytes32 slot, bytes32 value) external;
 23 |     | 
 24 |     |     // Signs data (privateKey, digest) => (v, r, s)
 25 |     |     function sign(
 26 |     |         uint256 privateKey,
 27 |     |         bytes32 digest
 28 |     |     ) external returns (uint8 v, bytes32 r, bytes32 s);
 29 |     | 
 30 |     |     // Gets address for a given private key
 31 |     |     function addr(uint256 privateKey) external returns (address addr);
 32 |     | 
 33 |     |     // Performs a foreign function call via terminal
 34 |     |     function ffi(
 35 |     |         string[] calldata inputs
 36 |     |     ) external returns (bytes memory result);
 37 |     | 
 38 |     |     // Performs the next smart contract call with specified `msg.sender`
 39 |     |     function prank(address newSender) external;
 40 |     | 
 41 |     |     // Creates a new fork with the given endpoint and the latest block and returns the identifier of the fork
 42 |     |     function createFork(string calldata urlOrAlias) external returns (uint256);
 43 |     | 
 44 |     |     // Takes a fork identifier created by createFork and sets the corresponding forked state as active
 45 |     |     function selectFork(uint256 forkId) external;
 46 |     | 
 47 |     |     // Returns the identifier of the current fork
 48 |     |     function activeFork() external returns (uint256);
 49 |     | 
 50 |     |     // Labels the address in traces
 51 |     |     function label(address addr, string calldata label) external;
 52 |     | }
 53 |     | 
 54 | *   | IHevm constant hevm = IHevm(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);
 55 |     | 

/mnt/c/Users/zerox/repos/bera.buzz-contracts/node_modules/@crytic/properties/contracts/util/PropertiesHelper.sol
   1 |     | // SPDX-License-Identifier: AGPL-3.0-or-later
   2 |     | pragma solidity ^0.8.0;
   3 |     | 
   4 |     | abstract contract PropertiesAsserts {
   5 |     |     event LogUint256(string, uint256);
   6 |     |     event LogAddress(string, address);
   7 |     |     event LogString(string);
   8 |     | 
   9 |     |     event AssertFail(string);
  10 |     |     event AssertEqFail(string);
  11 |     |     event AssertNeqFail(string);
  12 |     |     event AssertGteFail(string);
  13 |     |     event AssertGtFail(string);
  14 |     |     event AssertLteFail(string);
  15 |     |     event AssertLtFail(string);
  16 |     | 
  17 |     |     function assertWithMsg(bool b, string memory reason) internal {
  18 |     |         if (!b) {
  19 |     |             emit AssertFail(reason);
  20 |     |             assert(false);
  21 |     |         }
  22 |     |     }
  23 |     | 
  24 |     |     /// @notice asserts that a is equal to b. Violations are logged using reason.
  25 |     |     function assertEq(uint256 a, uint256 b, string memory reason) internal {
  26 |     |         if (a != b) {
  27 |     |             string memory aStr = PropertiesLibString.toString(a);
  28 |     |             string memory bStr = PropertiesLibString.toString(b);
  29 |     |             bytes memory assertMsg = abi.encodePacked(
  30 |     |                 "Invalid: ",
  31 |     |                 aStr,
  32 |     |                 "!=",
  33 |     |                 bStr,
  34 |     |                 ", reason: ",
  35 |     |                 reason
  36 |     |             );
  37 |     |             emit AssertEqFail(string(assertMsg));
  38 |     |             assert(false);
  39 |     |         }
  40 |     |     }
  41 |     | 
  42 |     |     /// @notice int256 version of assertEq
  43 |     |     function assertEq(int256 a, int256 b, string memory reason) internal {
  44 |     |         if (a != b) {
  45 |     |             string memory aStr = PropertiesLibString.toString(a);
  46 |     |             string memory bStr = PropertiesLibString.toString(b);
  47 |     |             bytes memory assertMsg = abi.encodePacked(
  48 |     |                 "Invalid: ",
  49 |     |                 aStr,
  50 |     |                 "!=",
  51 |     |                 bStr,
  52 |     |                 ", reason: ",
  53 |     |                 reason
  54 |     |             );
  55 |     |             emit AssertEqFail(string(assertMsg));
  56 |     |             assert(false);
  57 |     |         }
  58 |     |     }
  59 |     | 
  60 |     |     /// @notice asserts that a is not equal to b. Violations are logged using reason.
  61 |     |     function assertNeq(uint256 a, uint256 b, string memory reason) internal {
  62 |     |         if (a == b) {
  63 |     |             string memory aStr = PropertiesLibString.toString(a);
  64 |     |             string memory bStr = PropertiesLibString.toString(b);
  65 |     |             bytes memory assertMsg = abi.encodePacked(
  66 |     |                 "Invalid: ",
  67 |     |                 aStr,
  68 |     |                 "==",
  69 |     |                 bStr,
  70 |     |                 ", reason: ",
  71 |     |                 reason
  72 |     |             );
  73 |     |             emit AssertNeqFail(string(assertMsg));
  74 |     |             assert(false);
  75 |     |         }
  76 |     |     }
  77 |     | 
  78 |     |     /// @notice int256 version of assertNeq
  79 |     |     function assertNeq(int256 a, int256 b, string memory reason) internal {
  80 |     |         if (a == b) {
  81 |     |             string memory aStr = PropertiesLibString.toString(a);
  82 |     |             string memory bStr = PropertiesLibString.toString(b);
  83 |     |             bytes memory assertMsg = abi.encodePacked(
  84 |     |                 "Invalid: ",
  85 |     |                 aStr,
  86 |     |                 "==",
  87 |     |                 bStr,
  88 |     |                 ", reason: ",
  89 |     |                 reason
  90 |     |             );
  91 |     |             emit AssertNeqFail(string(assertMsg));
  92 |     |             assert(false);
  93 |     |         }
  94 |     |     }
  95 |     | 
  96 |     |     /// @notice asserts that a is greater than or equal to b. Violations are logged using reason.
  97 |     |     function assertGte(uint256 a, uint256 b, string memory reason) internal {
  98 |     |         if (!(a >= b)) {
  99 |     |             string memory aStr = PropertiesLibString.toString(a);
 100 |     |             string memory bStr = PropertiesLibString.toString(b);
 101 |     |             bytes memory assertMsg = abi.encodePacked(
 102 |     |                 "Invalid: ",
 103 |     |                 aStr,
 104 |     |                 "<",
 105 |     |                 bStr,
 106 |     |                 " failed, reason: ",
 107 |     |                 reason
 108 |     |             );
 109 |     |             emit AssertGteFail(string(assertMsg));
 110 |     |             assert(false);
 111 |     |         }
 112 |     |     }
 113 |     | 
 114 |     |     /// @notice int256 version of assertGte
 115 |     |     function assertGte(int256 a, int256 b, string memory reason) internal {
 116 |     |         if (!(a >= b)) {
 117 |     |             string memory aStr = PropertiesLibString.toString(a);
 118 |     |             string memory bStr = PropertiesLibString.toString(b);
 119 |     |             bytes memory assertMsg = abi.encodePacked(
 120 |     |                 "Invalid: ",
 121 |     |                 aStr,
 122 |     |                 "<",
 123 |     |                 bStr,
 124 |     |                 " failed, reason: ",
 125 |     |                 reason
 126 |     |             );
 127 |     |             emit AssertGteFail(string(assertMsg));
 128 |     |             assert(false);
 129 |     |         }
 130 |     |     }
 131 |     | 
 132 |     |     /// @notice asserts that a is greater than b. Violations are logged using reason.
 133 |     |     function assertGt(uint256 a, uint256 b, string memory reason) internal {
 134 |     |         if (!(a > b)) {
 135 |     |             string memory aStr = PropertiesLibString.toString(a);
 136 |     |             string memory bStr = PropertiesLibString.toString(b);
 137 |     |             bytes memory assertMsg = abi.encodePacked(
 138 |     |                 "Invalid: ",
 139 |     |                 aStr,
 140 |     |                 "<=",
 141 |     |                 bStr,
 142 |     |                 " failed, reason: ",
 143 |     |                 reason
 144 |     |             );
 145 |     |             emit AssertGtFail(string(assertMsg));
 146 |     |             assert(false);
 147 |     |         }
 148 |     |     }
 149 |     | 
 150 |     |     /// @notice int256 version of assertGt
 151 |     |     function assertGt(int256 a, int256 b, string memory reason) internal {
 152 |     |         if (!(a > b)) {
 153 |     |             string memory aStr = PropertiesLibString.toString(a);
 154 |     |             string memory bStr = PropertiesLibString.toString(b);
 155 |     |             bytes memory assertMsg = abi.encodePacked(
 156 |     |                 "Invalid: ",
 157 |     |                 aStr,
 158 |     |                 "<=",
 159 |     |                 bStr,
 160 |     |                 " failed, reason: ",
 161 |     |                 reason
 162 |     |             );
 163 |     |             emit AssertGtFail(string(assertMsg));
 164 |     |             assert(false);
 165 |     |         }
 166 |     |     }
 167 |     | 
 168 |     |     /// @notice asserts that a is less than or equal to b. Violations are logged using reason.
 169 |     |     function assertLte(uint256 a, uint256 b, string memory reason) internal {
 170 |     |         if (!(a <= b)) {
 171 |     |             string memory aStr = PropertiesLibString.toString(a);
 172 |     |             string memory bStr = PropertiesLibString.toString(b);
 173 |     |             bytes memory assertMsg = abi.encodePacked(
 174 |     |                 "Invalid: ",
 175 |     |                 aStr,
 176 |     |                 ">",
 177 |     |                 bStr,
 178 |     |                 " failed, reason: ",
 179 |     |                 reason
 180 |     |             );
 181 |     |             emit AssertLteFail(string(assertMsg));
 182 |     |             assert(false);
 183 |     |         }
 184 |     |     }
 185 |     | 
 186 |     |     /// @notice int256 version of assertLte
 187 |     |     function assertLte(int256 a, int256 b, string memory reason) internal {
 188 |     |         if (!(a <= b)) {
 189 |     |             string memory aStr = PropertiesLibString.toString(a);
 190 |     |             string memory bStr = PropertiesLibString.toString(b);
 191 |     |             bytes memory assertMsg = abi.encodePacked(
 192 |     |                 "Invalid: ",
 193 |     |                 aStr,
 194 |     |                 ">",
 195 |     |                 bStr,
 196 |     |                 " failed, reason: ",
 197 |     |                 reason
 198 |     |             );
 199 |     |             emit AssertLteFail(string(assertMsg));
 200 |     |             assert(false);
 201 |     |         }
 202 |     |     }
 203 |     | 
 204 |     |     /// @notice asserts that a is less than b. Violations are logged using reason.
 205 |     |     function assertLt(uint256 a, uint256 b, string memory reason) internal {
 206 |     |         if (!(a < b)) {
 207 |     |             string memory aStr = PropertiesLibString.toString(a);
 208 |     |             string memory bStr = PropertiesLibString.toString(b);
 209 |     |             bytes memory assertMsg = abi.encodePacked(
 210 |     |                 "Invalid: ",
 211 |     |                 aStr,
 212 |     |                 ">=",
 213 |     |                 bStr,
 214 |     |                 " failed, reason: ",
 215 |     |                 reason
 216 |     |             );
 217 |     |             emit AssertLtFail(string(assertMsg));
 218 |     |             assert(false);
 219 |     |         }
 220 |     |     }
 221 |     | 
 222 |     |     /// @notice int256 version of assertLt
 223 |     |     function assertLt(int256 a, int256 b, string memory reason) internal {
 224 |     |         if (!(a < b)) {
 225 |     |             string memory aStr = PropertiesLibString.toString(a);
 226 |     |             string memory bStr = PropertiesLibString.toString(b);
 227 |     |             bytes memory assertMsg = abi.encodePacked(
 228 |     |                 "Invalid: ",
 229 |     |                 aStr,
 230 |     |                 ">=",
 231 |     |                 bStr,
 232 |     |                 " failed, reason: ",
 233 |     |                 reason
 234 |     |             );
 235 |     |             emit AssertLtFail(string(assertMsg));
 236 |     |             assert(false);
 237 |     |         }
 238 |     |     }
 239 |     | 
 240 |     |     /// @notice Clamps value to be between low and high, both inclusive
 241 | *   |     function clampBetween(
 242 |     |         uint256 value,
 243 |     |         uint256 low,
 244 |     |         uint256 high
 245 | *   |     ) internal returns (uint256) {
 246 | *   |         if (value < low || value > high) {
 247 | *   |             uint ans = low + (value % (high - low + 1));
 248 | *   |             string memory valueStr = PropertiesLibString.toString(value);
 249 | *   |             string memory ansStr = PropertiesLibString.toString(ans);
 250 | *   |             bytes memory message = abi.encodePacked(
 251 |     |                 "Clamping value ",
 252 | *   |                 valueStr,
 253 |     |                 " to ",
 254 | *   |                 ansStr
 255 |     |             );
 256 | *   |             emit LogString(string(message));
 257 | *   |             return ans;
 258 |     |         }
 259 | *   |         return value;
 260 |     |     }
 261 |     | 
 262 |     |     /// @notice int256 version of clampBetween
 263 |     |     function clampBetween(
 264 |     |         int256 value,
 265 |     |         int256 low,
 266 |     |         int256 high
 267 |     |     ) internal returns (int256) {
 268 |     |         if (value < low || value > high) {
 269 |     |             int range = high - low + 1;
 270 |     |             int clamped = (value - low) % (range);
 271 |     |             if (clamped < 0) clamped += range;
 272 |     |             int ans = low + clamped;
 273 |     |             string memory valueStr = PropertiesLibString.toString(value);
 274 |     |             string memory ansStr = PropertiesLibString.toString(ans);
 275 |     |             bytes memory message = abi.encodePacked(
 276 |     |                 "Clamping value ",
 277 |     |                 valueStr,
 278 |     |                 " to ",
 279 |     |                 ansStr
 280 |     |             );
 281 |     |             emit LogString(string(message));
 282 |     |             return ans;
 283 |     |         }
 284 |     |         return value;
 285 |     |     }
 286 |     | 
 287 |     |     /// @notice clamps a to be less than b
 288 |     |     function clampLt(uint256 a, uint256 b) internal returns (uint256) {
 289 |     |         if (!(a < b)) {
 290 |     |             assertNeq(
 291 |     |                 b,
 292 |     |                 0,
 293 |     |                 "clampLt cannot clamp value a to be less than zero. Check your inputs/assumptions."
 294 |     |             );
 295 |     |             uint256 value = a % b;
 296 |     |             string memory aStr = PropertiesLibString.toString(a);
 297 |     |             string memory valueStr = PropertiesLibString.toString(value);
 298 |     |             bytes memory message = abi.encodePacked(
 299 |     |                 "Clamping value ",
 300 |     |                 aStr,
 301 |     |                 " to ",
 302 |     |                 valueStr
 303 |     |             );
 304 |     |             emit LogString(string(message));
 305 |     |             return value;
 306 |     |         }
 307 |     |         return a;
 308 |     |     }
 309 |     | 
 310 |     |     /// @notice int256 version of clampLt
 311 |     |     function clampLt(int256 a, int256 b) internal returns (int256) {
 312 |     |         if (!(a < b)) {
 313 |     |             int256 value = b - 1;
 314 |     |             string memory aStr = PropertiesLibString.toString(a);
 315 |     |             string memory valueStr = PropertiesLibString.toString(value);
 316 |     |             bytes memory message = abi.encodePacked(
 317 |     |                 "Clamping value ",
 318 |     |                 aStr,
 319 |     |                 " to ",
 320 |     |                 valueStr
 321 |     |             );
 322 |     |             emit LogString(string(message));
 323 |     |             return value;
 324 |     |         }
 325 |     |         return a;
 326 |     |     }
 327 |     | 
 328 |     |     /// @notice clamps a to be less than or equal to b
 329 |     |     function clampLte(uint256 a, uint256 b) internal returns (uint256) {
 330 |     |         if (!(a <= b)) {
 331 |     |             uint256 value = a % (b + 1);
 332 |     |             string memory aStr = PropertiesLibString.toString(a);
 333 |     |             string memory valueStr = PropertiesLibString.toString(value);
 334 |     |             bytes memory message = abi.encodePacked(
 335 |     |                 "Clamping value ",
 336 |     |                 aStr,
 337 |     |                 " to ",
 338 |     |                 valueStr
 339 |     |             );
 340 |     |             emit LogString(string(message));
 341 |     |             return value;
 342 |     |         }
 343 |     |         return a;
 344 |     |     }
 345 |     | 
 346 |     |     /// @notice int256 version of clampLte
 347 |     |     function clampLte(int256 a, int256 b) internal returns (int256) {
 348 |     |         if (!(a <= b)) {
 349 |     |             int256 value = b;
 350 |     |             string memory aStr = PropertiesLibString.toString(a);
 351 |     |             string memory valueStr = PropertiesLibString.toString(value);
 352 |     |             bytes memory message = abi.encodePacked(
 353 |     |                 "Clamping value ",
 354 |     |                 aStr,
 355 |     |                 " to ",
 356 |     |                 valueStr
 357 |     |             );
 358 |     |             emit LogString(string(message));
 359 |     |             return value;
 360 |     |         }
 361 |     |         return a;
 362 |     |     }
 363 |     | 
 364 |     |     /// @notice clamps a to be greater than b
 365 |     |     function clampGt(uint256 a, uint256 b) internal returns (uint256) {
 366 |     |         if (!(a > b)) {
 367 |     |             assertNeq(
 368 |     |                 b,
 369 |     |                 type(uint256).max,
 370 |     |                 "clampGt cannot clamp value a to be larger than uint256.max. Check your inputs/assumptions."
 371 |     |             );
 372 |     |             uint256 value = b + 1;
 373 |     |             string memory aStr = PropertiesLibString.toString(a);
 374 |     |             string memory valueStr = PropertiesLibString.toString(value);
 375 |     |             bytes memory message = abi.encodePacked(
 376 |     |                 "Clamping value ",
 377 |     |                 aStr,
 378 |     |                 " to ",
 379 |     |                 valueStr
 380 |     |             );
 381 |     |             emit LogString(string(message));
 382 |     |             return value;
 383 |     |         } else {
 384 |     |             return a;
 385 |     |         }
 386 |     |     }
 387 |     | 
 388 |     |     /// @notice int256 version of clampGt
 389 |     |     function clampGt(int256 a, int256 b) internal returns (int256) {
 390 |     |         if (!(a > b)) {
 391 |     |             int256 value = b + 1;
 392 |     |             string memory aStr = PropertiesLibString.toString(a);
 393 |     |             string memory valueStr = PropertiesLibString.toString(value);
 394 |     |             bytes memory message = abi.encodePacked(
 395 |     |                 "Clamping value ",
 396 |     |                 aStr,
 397 |     |                 " to ",
 398 |     |                 valueStr
 399 |     |             );
 400 |     |             emit LogString(string(message));
 401 |     |             return value;
 402 |     |         } else {
 403 |     |             return a;
 404 |     |         }
 405 |     |     }
 406 |     | 
 407 |     |     /// @notice clamps a to be greater than or equal to b
 408 |     |     function clampGte(uint256 a, uint256 b) internal returns (uint256) {
 409 |     |         if (!(a > b)) {
 410 |     |             uint256 value = b;
 411 |     |             string memory aStr = PropertiesLibString.toString(a);
 412 |     |             string memory valueStr = PropertiesLibString.toString(value);
 413 |     |             bytes memory message = abi.encodePacked(
 414 |     |                 "Clamping value ",
 415 |     |                 aStr,
 416 |     |                 " to ",
 417 |     |                 valueStr
 418 |     |             );
 419 |     |             emit LogString(string(message));
 420 |     |             return value;
 421 |     |         }
 422 |     |         return a;
 423 |     |     }
 424 |     | 
 425 |     |     /// @notice int256 version of clampGte
 426 |     |     function clampGte(int256 a, int256 b) internal returns (int256) {
 427 |     |         if (!(a > b)) {
 428 |     |             int256 value = b;
 429 |     |             string memory aStr = PropertiesLibString.toString(a);
 430 |     |             string memory valueStr = PropertiesLibString.toString(value);
 431 |     |             bytes memory message = abi.encodePacked(
 432 |     |                 "Clamping value ",
 433 |     |                 aStr,
 434 |     |                 " to ",
 435 |     |                 valueStr
 436 |     |             );
 437 |     |             emit LogString(string(message));
 438 |     |             return value;
 439 |     |         }
 440 |     |         return a;
 441 |     |     }
 442 |     | }
 443 |     | 
 444 |     | /// @notice Efficient library for creating string representations of integers.
 445 |     | /// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/LibString.sol)
 446 |     | /// @author Modified from Solady (https://github.com/Vectorized/solady/blob/main/src/utils/LibString.sol)
 447 |     | /// @dev Name of the library is modified to prevent collisions with contract-under-test uses of LibString
 448 |     | library PropertiesLibString {
 449 |     |     function toString(int256 value) internal pure returns (string memory str) {
 450 |     |         uint256 absValue = value >= 0 ? uint256(value) : uint256(-value);
 451 |     |         str = toString(absValue);
 452 |     | 
 453 |     |         if (value < 0) {
 454 |     |             str = string(abi.encodePacked("-", str));
 455 |     |         }
 456 |     |     }
 457 |     | 
 458 | *   |     function toString(uint256 value) internal pure returns (string memory str) {
 459 |     |         /// @solidity memory-safe-assembly
 460 | *   |         assembly {
 461 |     |             // The maximum value of a uint256 contains 78 digits (1 byte per digit), but we allocate 160 bytes
 462 |     |             // to keep the free memory pointer word aligned. We'll need 1 word for the length, 1 word for the
 463 |     |             // trailing zeros padding, and 3 other words for a max of 78 digits. In total: 5 * 32 = 160 bytes.
 464 | *   |             let newFreeMemoryPointer := add(mload(0x40), 160)
 465 |     | 
 466 |     |             // Update the free memory pointer to avoid overriding our string.
 467 | *   |             mstore(0x40, newFreeMemoryPointer)
 468 |     | 
 469 |     |             // Assign str to the end of the zone of newly allocated memory.
 470 | *   |             str := sub(newFreeMemoryPointer, 32)
 471 |     | 
 472 |     |             // Clean the last word of memory it may not be overwritten.
 473 | *   |             mstore(str, 0)
 474 |     | 
 475 |     |             // Cache the end of the memory to calculate the length later.
 476 | *   |             let end := str
 477 |     | 
 478 |     |             // We write the string from rightmost digit to leftmost digit.
 479 |     |             // The following is essentially a do-while loop that also handles the zero case.
 480 |     |             // prettier-ignore
 481 | *   |             for { let temp := value } 1 {} {
 482 |     |                 // Move the pointer 1 byte to the left.
 483 | *   |                 str := sub(str, 1)
 484 |     | 
 485 |     |                 // Write the character to the pointer.
 486 |     |                 // The ASCII index of the '0' character is 48.
 487 | *   |                 mstore8(str, add(48, mod(temp, 10)))
 488 |     | 
 489 |     |                 // Keep dividing temp until zero.
 490 | *   |                 temp := div(temp, 10)
 491 |     | 
 492 |     |                  // prettier-ignore
 493 | *   |                 if iszero(temp) { break }
 494 |     |             }
 495 |     | 
 496 |     |             // Compute and cache the final total length of the string.
 497 | *   |             let length := sub(end, str)
 498 |     | 
 499 |     |             // Move the pointer 32 bytes leftwards to make room for the length.
 500 | *   |             str := sub(str, 32)
 501 |     | 
 502 |     |             // Store the string's length at the start of memory allocated for our string.
 503 | *   |             mstore(str, length)
 504 |     |         }
 505 |     |     }
 506 |     | 
 507 |     |     function toString(address value) internal pure returns (string memory str) {
 508 |     |         bytes memory s = new bytes(40);
 509 |     |         for (uint i = 0; i < 20; i++) {
 510 |     |             bytes1 b = bytes1(
 511 |     |                 uint8(uint(uint160(value)) / (2 ** (8 * (19 - i))))
 512 |     |             );
 513 |     |             bytes1 hi = bytes1(uint8(b) / 16);
 514 |     |             bytes1 lo = bytes1(uint8(b) - 16 * uint8(hi));
 515 |     |             s[2 * i] = char(hi);
 516 |     |             s[2 * i + 1] = char(lo);
 517 |     |         }
 518 |     |         return string(s);
 519 |     |     }
 520 |     | 
 521 |     |     function char(bytes1 b) internal pure returns (bytes1 c) {
 522 |     |         if (uint8(b) < 10) return bytes1(uint8(b) + 0x30);
 523 |     |         else return bytes1(uint8(b) + 0x57);
 524 |     |     }
 525 |     | }
 526 |     | 

/mnt/c/Users/zerox/repos/bera.buzz-contracts/node_modules/@openzeppelin/contracts/access/AccessControl.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v4.9.0) (access/AccessControl.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.0;
   5 |     | 
   6 |     | import "./IAccessControl.sol";
   7 |     | import "../utils/Context.sol";
   8 |     | import "../utils/Strings.sol";
   9 |     | import "../utils/introspection/ERC165.sol";
  10 |     | 
  11 |     | /**
  12 |     |  * @dev Contract module that allows children to implement role-based access
  13 |     |  * control mechanisms. This is a lightweight version that doesn't allow enumerating role
  14 |     |  * members except through off-chain means by accessing the contract event logs. Some
  15 |     |  * applications may benefit from on-chain enumerability, for those cases see
  16 |     |  * {AccessControlEnumerable}.
  17 |     |  *
  18 |     |  * Roles are referred to by their `bytes32` identifier. These should be exposed
  19 |     |  * in the external API and be unique. The best way to achieve this is by
  20 |     |  * using `public constant` hash digests:
  21 |     |  *
  22 |     |  * ```solidity
  23 |     |  * bytes32 public constant MY_ROLE = keccak256("MY_ROLE");
  24 |     |  * ```
  25 |     |  *
  26 |     |  * Roles can be used to represent a set of permissions. To restrict access to a
  27 |     |  * function call, use {hasRole}:
  28 |     |  *
  29 |     |  * ```solidity
  30 |     |  * function foo() public {
  31 |     |  *     require(hasRole(MY_ROLE, msg.sender));
  32 |     |  *     ...
  33 |     |  * }
  34 |     |  * ```
  35 |     |  *
  36 |     |  * Roles can be granted and revoked dynamically via the {grantRole} and
  37 |     |  * {revokeRole} functions. Each role has an associated admin role, and only
  38 |     |  * accounts that have a role's admin role can call {grantRole} and {revokeRole}.
  39 |     |  *
  40 |     |  * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means
  41 |     |  * that only accounts with this role will be able to grant or revoke other
  42 |     |  * roles. More complex role relationships can be created by using
  43 |     |  * {_setRoleAdmin}.
  44 |     |  *
  45 |     |  * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to
  46 |     |  * grant and revoke this role. Extra precautions should be taken to secure
  47 |     |  * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}
  48 |     |  * to enforce additional security measures for this role.
  49 |     |  */
  50 |     | abstract contract AccessControl is Context, IAccessControl, ERC165 {
  51 |     |     struct RoleData {
  52 |     |         mapping(address => bool) members;
  53 |     |         bytes32 adminRole;
  54 |     |     }
  55 |     | 
  56 |     |     mapping(bytes32 => RoleData) private _roles;
  57 |     | 
  58 |     |     bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;
  59 |     | 
  60 |     |     /**
  61 |     |      * @dev Modifier that checks that an account has a specific role. Reverts
  62 |     |      * with a standardized message including the required role.
  63 |     |      *
  64 |     |      * The format of the revert reason is given by the following regular expression:
  65 |     |      *
  66 |     |      *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/
  67 |     |      *
  68 |     |      * _Available since v4.1._
  69 |     |      */
  70 |     |     modifier onlyRole(bytes32 role) {
  71 | *   |         _checkRole(role);
  72 |     |         _;
  73 |     |     }
  74 |     | 
  75 |     |     /**
  76 |     |      * @dev See {IERC165-supportsInterface}.
  77 |     |      */
  78 |     |     function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
  79 |     |         return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);
  80 |     |     }
  81 |     | 
  82 |     |     /**
  83 |     |      * @dev Returns `true` if `account` has been granted `role`.
  84 |     |      */
  85 | *   |     function hasRole(bytes32 role, address account) public view virtual override returns (bool) {
  86 | *   |         return _roles[role].members[account];
  87 |     |     }
  88 |     | 
  89 |     |     /**
  90 |     |      * @dev Revert with a standard message if `_msgSender()` is missing `role`.
  91 |     |      * Overriding this function changes the behavior of the {onlyRole} modifier.
  92 |     |      *
  93 |     |      * Format of the revert message is described in {_checkRole}.
  94 |     |      *
  95 |     |      * _Available since v4.6._
  96 |     |      */
  97 | *   |     function _checkRole(bytes32 role) internal view virtual {
  98 | *   |         _checkRole(role, _msgSender());
  99 |     |     }
 100 |     | 
 101 |     |     /**
 102 |     |      * @dev Revert with a standard message if `account` is missing `role`.
 103 |     |      *
 104 |     |      * The format of the revert reason is given by the following regular expression:
 105 |     |      *
 106 |     |      *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/
 107 |     |      */
 108 | *   |     function _checkRole(bytes32 role, address account) internal view virtual {
 109 | *   |         if (!hasRole(role, account)) {
 110 |     |             revert(
 111 |     |                 string(
 112 |     |                     abi.encodePacked(
 113 |     |                         "AccessControl: account ",
 114 |     |                         Strings.toHexString(account),
 115 |     |                         " is missing role ",
 116 |     |                         Strings.toHexString(uint256(role), 32)
 117 |     |                     )
 118 |     |                 )
 119 |     |             );
 120 |     |         }
 121 |     |     }
 122 |     | 
 123 |     |     /**
 124 |     |      * @dev Returns the admin role that controls `role`. See {grantRole} and
 125 |     |      * {revokeRole}.
 126 |     |      *
 127 |     |      * To change a role's admin, use {_setRoleAdmin}.
 128 |     |      */
 129 |     |     function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {
 130 |     |         return _roles[role].adminRole;
 131 |     |     }
 132 |     | 
 133 |     |     /**
 134 |     |      * @dev Grants `role` to `account`.
 135 |     |      *
 136 |     |      * If `account` had not been already granted `role`, emits a {RoleGranted}
 137 |     |      * event.
 138 |     |      *
 139 |     |      * Requirements:
 140 |     |      *
 141 |     |      * - the caller must have ``role``'s admin role.
 142 |     |      *
 143 |     |      * May emit a {RoleGranted} event.
 144 |     |      */
 145 |     |     function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {
 146 |     |         _grantRole(role, account);
 147 |     |     }
 148 |     | 
 149 |     |     /**
 150 |     |      * @dev Revokes `role` from `account`.
 151 |     |      *
 152 |     |      * If `account` had been granted `role`, emits a {RoleRevoked} event.
 153 |     |      *
 154 |     |      * Requirements:
 155 |     |      *
 156 |     |      * - the caller must have ``role``'s admin role.
 157 |     |      *
 158 |     |      * May emit a {RoleRevoked} event.
 159 |     |      */
 160 |     |     function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {
 161 |     |         _revokeRole(role, account);
 162 |     |     }
 163 |     | 
 164 |     |     /**
 165 |     |      * @dev Revokes `role` from the calling account.
 166 |     |      *
 167 |     |      * Roles are often managed via {grantRole} and {revokeRole}: this function's
 168 |     |      * purpose is to provide a mechanism for accounts to lose their privileges
 169 |     |      * if they are compromised (such as when a trusted device is misplaced).
 170 |     |      *
 171 |     |      * If the calling account had been revoked `role`, emits a {RoleRevoked}
 172 |     |      * event.
 173 |     |      *
 174 |     |      * Requirements:
 175 |     |      *
 176 |     |      * - the caller must be `account`.
 177 |     |      *
 178 |     |      * May emit a {RoleRevoked} event.
 179 |     |      */
 180 |     |     function renounceRole(bytes32 role, address account) public virtual override {
 181 |     |         require(account == _msgSender(), "AccessControl: can only renounce roles for self");
 182 |     | 
 183 |     |         _revokeRole(role, account);
 184 |     |     }
 185 |     | 
 186 |     |     /**
 187 |     |      * @dev Grants `role` to `account`.
 188 |     |      *
 189 |     |      * If `account` had not been already granted `role`, emits a {RoleGranted}
 190 |     |      * event. Note that unlike {grantRole}, this function doesn't perform any
 191 |     |      * checks on the calling account.
 192 |     |      *
 193 |     |      * May emit a {RoleGranted} event.
 194 |     |      *
 195 |     |      * [WARNING]
 196 |     |      * ====
 197 |     |      * This function should only be called from the constructor when setting
 198 |     |      * up the initial roles for the system.
 199 |     |      *
 200 |     |      * Using this function in any other way is effectively circumventing the admin
 201 |     |      * system imposed by {AccessControl}.
 202 |     |      * ====
 203 |     |      *
 204 |     |      * NOTE: This function is deprecated in favor of {_grantRole}.
 205 |     |      */
 206 |     |     function _setupRole(bytes32 role, address account) internal virtual {
 207 |     |         _grantRole(role, account);
 208 |     |     }
 209 |     | 
 210 |     |     /**
 211 |     |      * @dev Sets `adminRole` as ``role``'s admin role.
 212 |     |      *
 213 |     |      * Emits a {RoleAdminChanged} event.
 214 |     |      */
 215 |     |     function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {
 216 |     |         bytes32 previousAdminRole = getRoleAdmin(role);
 217 |     |         _roles[role].adminRole = adminRole;
 218 |     |         emit RoleAdminChanged(role, previousAdminRole, adminRole);
 219 |     |     }
 220 |     | 
 221 |     |     /**
 222 |     |      * @dev Grants `role` to `account`.
 223 |     |      *
 224 |     |      * Internal function without access restriction.
 225 |     |      *
 226 |     |      * May emit a {RoleGranted} event.
 227 |     |      */
 228 | *   |     function _grantRole(bytes32 role, address account) internal virtual {
 229 | *   |         if (!hasRole(role, account)) {
 230 | *   |             _roles[role].members[account] = true;
 231 | *   |             emit RoleGranted(role, account, _msgSender());
 232 |     |         }
 233 |     |     }
 234 |     | 
 235 |     |     /**
 236 |     |      * @dev Revokes `role` from `account`.
 237 |     |      *
 238 |     |      * Internal function without access restriction.
 239 |     |      *
 240 |     |      * May emit a {RoleRevoked} event.
 241 |     |      */
 242 |     |     function _revokeRole(bytes32 role, address account) internal virtual {
 243 |     |         if (hasRole(role, account)) {
 244 |     |             _roles[role].members[account] = false;
 245 |     |             emit RoleRevoked(role, account, _msgSender());
 246 |     |         }
 247 |     |     }
 248 |     | }
 249 |     | 

/mnt/c/Users/zerox/repos/bera.buzz-contracts/node_modules/@openzeppelin/contracts/access/IAccessControl.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | /**
  7 |     |  * @dev External interface of AccessControl declared to support ERC165 detection.
  8 |     |  */
  9 |     | interface IAccessControl {
 10 |     |     /**
 11 |     |      * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`
 12 |     |      *
 13 |     |      * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite
 14 |     |      * {RoleAdminChanged} not being emitted signaling this.
 15 |     |      *
 16 |     |      * _Available since v3.1._
 17 |     |      */
 18 |     |     event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);
 19 |     | 
 20 |     |     /**
 21 |     |      * @dev Emitted when `account` is granted `role`.
 22 |     |      *
 23 |     |      * `sender` is the account that originated the contract call, an admin role
 24 |     |      * bearer except when using {AccessControl-_setupRole}.
 25 |     |      */
 26 |     |     event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);
 27 |     | 
 28 |     |     /**
 29 |     |      * @dev Emitted when `account` is revoked `role`.
 30 |     |      *
 31 |     |      * `sender` is the account that originated the contract call:
 32 |     |      *   - if using `revokeRole`, it is the admin role bearer
 33 |     |      *   - if using `renounceRole`, it is the role bearer (i.e. `account`)
 34 |     |      */
 35 |     |     event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);
 36 |     | 
 37 |     |     /**
 38 |     |      * @dev Returns `true` if `account` has been granted `role`.
 39 |     |      */
 40 |     |     function hasRole(bytes32 role, address account) external view returns (bool);
 41 |     | 
 42 |     |     /**
 43 |     |      * @dev Returns the admin role that controls `role`. See {grantRole} and
 44 |     |      * {revokeRole}.
 45 |     |      *
 46 |     |      * To change a role's admin, use {AccessControl-_setRoleAdmin}.
 47 |     |      */
 48 |     |     function getRoleAdmin(bytes32 role) external view returns (bytes32);
 49 |     | 
 50 |     |     /**
 51 |     |      * @dev Grants `role` to `account`.
 52 |     |      *
 53 |     |      * If `account` had not been already granted `role`, emits a {RoleGranted}
 54 |     |      * event.
 55 |     |      *
 56 |     |      * Requirements:
 57 |     |      *
 58 |     |      * - the caller must have ``role``'s admin role.
 59 |     |      */
 60 |     |     function grantRole(bytes32 role, address account) external;
 61 |     | 
 62 |     |     /**
 63 |     |      * @dev Revokes `role` from `account`.
 64 |     |      *
 65 |     |      * If `account` had been granted `role`, emits a {RoleRevoked} event.
 66 |     |      *
 67 |     |      * Requirements:
 68 |     |      *
 69 |     |      * - the caller must have ``role``'s admin role.
 70 |     |      */
 71 |     |     function revokeRole(bytes32 role, address account) external;
 72 |     | 
 73 |     |     /**
 74 |     |      * @dev Revokes `role` from the calling account.
 75 |     |      *
 76 |     |      * Roles are often managed via {grantRole} and {revokeRole}: this function's
 77 |     |      * purpose is to provide a mechanism for accounts to lose their privileges
 78 |     |      * if they are compromised (such as when a trusted device is misplaced).
 79 |     |      *
 80 |     |      * If the calling account had been granted `role`, emits a {RoleRevoked}
 81 |     |      * event.
 82 |     |      *
 83 |     |      * Requirements:
 84 |     |      *
 85 |     |      * - the caller must be `account`.
 86 |     |      */
 87 |     |     function renounceRole(bytes32 role, address account) external;
 88 |     | }
 89 |     | 

/mnt/c/Users/zerox/repos/bera.buzz-contracts/node_modules/@openzeppelin/contracts/access/Ownable.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | import "../utils/Context.sol";
  7 |     | 
  8 |     | /**
  9 |     |  * @dev Contract module which provides a basic access control mechanism, where
 10 |     |  * there is an account (an owner) that can be granted exclusive access to
 11 |     |  * specific functions.
 12 |     |  *
 13 |     |  * By default, the owner account will be the one that deploys the contract. This
 14 |     |  * can later be changed with {transferOwnership}.
 15 |     |  *
 16 |     |  * This module is used through inheritance. It will make available the modifier
 17 |     |  * `onlyOwner`, which can be applied to your functions to restrict their use to
 18 |     |  * the owner.
 19 |     |  */
 20 |     | abstract contract Ownable is Context {
 21 |     |     address private _owner;
 22 |     | 
 23 |     |     event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
 24 |     | 
 25 |     |     /**
 26 |     |      * @dev Initializes the contract setting the deployer as the initial owner.
 27 |     |      */
 28 |     |     constructor() {
 29 | *   |         _transferOwnership(_msgSender());
 30 |     |     }
 31 |     | 
 32 |     |     /**
 33 |     |      * @dev Throws if called by any account other than the owner.
 34 |     |      */
 35 |     |     modifier onlyOwner() {
 36 | *   |         _checkOwner();
 37 |     |         _;
 38 |     |     }
 39 |     | 
 40 |     |     /**
 41 |     |      * @dev Returns the address of the current owner.
 42 |     |      */
 43 | *   |     function owner() public view virtual returns (address) {
 44 | *   |         return _owner;
 45 |     |     }
 46 |     | 
 47 |     |     /**
 48 |     |      * @dev Throws if the sender is not the owner.
 49 |     |      */
 50 | *   |     function _checkOwner() internal view virtual {
 51 | *   |         require(owner() == _msgSender(), "Ownable: caller is not the owner");
 52 |     |     }
 53 |     | 
 54 |     |     /**
 55 |     |      * @dev Leaves the contract without owner. It will not be possible to call
 56 |     |      * `onlyOwner` functions. Can only be called by the current owner.
 57 |     |      *
 58 |     |      * NOTE: Renouncing ownership will leave the contract without an owner,
 59 |     |      * thereby disabling any functionality that is only available to the owner.
 60 |     |      */
 61 |     |     function renounceOwnership() public virtual onlyOwner {
 62 |     |         _transferOwnership(address(0));
 63 |     |     }
 64 |     | 
 65 |     |     /**
 66 |     |      * @dev Transfers ownership of the contract to a new account (`newOwner`).
 67 |     |      * Can only be called by the current owner.
 68 |     |      */
 69 |     |     function transferOwnership(address newOwner) public virtual onlyOwner {
 70 |     |         require(newOwner != address(0), "Ownable: new owner is the zero address");
 71 |     |         _transferOwnership(newOwner);
 72 |     |     }
 73 |     | 
 74 |     |     /**
 75 |     |      * @dev Transfers ownership of the contract to a new account (`newOwner`).
 76 |     |      * Internal function without access restriction.
 77 |     |      */
 78 | *   |     function _transferOwnership(address newOwner) internal virtual {
 79 | *   |         address oldOwner = _owner;
 80 | *   |         _owner = newOwner;
 81 | *   |         emit OwnershipTransferred(oldOwner, newOwner);
 82 |     |     }
 83 |     | }
 84 |     | 

/mnt/c/Users/zerox/repos/bera.buzz-contracts/node_modules/@openzeppelin/contracts/security/Pausable.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.0;
   5 |     | 
   6 |     | import "../utils/Context.sol";
   7 |     | 
   8 |     | /**
   9 |     |  * @dev Contract module which allows children to implement an emergency stop
  10 |     |  * mechanism that can be triggered by an authorized account.
  11 |     |  *
  12 |     |  * This module is used through inheritance. It will make available the
  13 |     |  * modifiers `whenNotPaused` and `whenPaused`, which can be applied to
  14 |     |  * the functions of your contract. Note that they will not be pausable by
  15 |     |  * simply including this module, only once the modifiers are put in place.
  16 |     |  */
  17 |     | abstract contract Pausable is Context {
  18 |     |     /**
  19 |     |      * @dev Emitted when the pause is triggered by `account`.
  20 |     |      */
  21 |     |     event Paused(address account);
  22 |     | 
  23 |     |     /**
  24 |     |      * @dev Emitted when the pause is lifted by `account`.
  25 |     |      */
  26 |     |     event Unpaused(address account);
  27 |     | 
  28 |     |     bool private _paused;
  29 |     | 
  30 |     |     /**
  31 |     |      * @dev Initializes the contract in unpaused state.
  32 |     |      */
  33 |     |     constructor() {
  34 | *   |         _paused = false;
  35 |     |     }
  36 |     | 
  37 |     |     /**
  38 |     |      * @dev Modifier to make a function callable only when the contract is not paused.
  39 |     |      *
  40 |     |      * Requirements:
  41 |     |      *
  42 |     |      * - The contract must not be paused.
  43 |     |      */
  44 |     |     modifier whenNotPaused() {
  45 |     |         _requireNotPaused();
  46 |     |         _;
  47 |     |     }
  48 |     | 
  49 |     |     /**
  50 |     |      * @dev Modifier to make a function callable only when the contract is paused.
  51 |     |      *
  52 |     |      * Requirements:
  53 |     |      *
  54 |     |      * - The contract must be paused.
  55 |     |      */
  56 |     |     modifier whenPaused() {
  57 |     |         _requirePaused();
  58 |     |         _;
  59 |     |     }
  60 |     | 
  61 |     |     /**
  62 |     |      * @dev Returns true if the contract is paused, and false otherwise.
  63 |     |      */
  64 |     |     function paused() public view virtual returns (bool) {
  65 |     |         return _paused;
  66 |     |     }
  67 |     | 
  68 |     |     /**
  69 |     |      * @dev Throws if the contract is paused.
  70 |     |      */
  71 |     |     function _requireNotPaused() internal view virtual {
  72 |     |         require(!paused(), "Pausable: paused");
  73 |     |     }
  74 |     | 
  75 |     |     /**
  76 |     |      * @dev Throws if the contract is not paused.
  77 |     |      */
  78 |     |     function _requirePaused() internal view virtual {
  79 |     |         require(paused(), "Pausable: not paused");
  80 |     |     }
  81 |     | 
  82 |     |     /**
  83 |     |      * @dev Triggers stopped state.
  84 |     |      *
  85 |     |      * Requirements:
  86 |     |      *
  87 |     |      * - The contract must not be paused.
  88 |     |      */
  89 |     |     function _pause() internal virtual whenNotPaused {
  90 |     |         _paused = true;
  91 |     |         emit Paused(_msgSender());
  92 |     |     }
  93 |     | 
  94 |     |     /**
  95 |     |      * @dev Returns to normal state.
  96 |     |      *
  97 |     |      * Requirements:
  98 |     |      *
  99 |     |      * - The contract must be paused.
 100 |     |      */
 101 |     |     function _unpause() internal virtual whenPaused {
 102 |     |         _paused = false;
 103 |     |         emit Unpaused(_msgSender());
 104 |     |     }
 105 |     | }
 106 |     | 

/mnt/c/Users/zerox/repos/bera.buzz-contracts/node_modules/@openzeppelin/contracts/token/ERC20/ERC20.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/ERC20.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.0;
   5 |     | 
   6 |     | import "./IERC20.sol";
   7 |     | import "./extensions/IERC20Metadata.sol";
   8 |     | import "../../utils/Context.sol";
   9 |     | 
  10 |     | /**
  11 |     |  * @dev Implementation of the {IERC20} interface.
  12 |     |  *
  13 |     |  * This implementation is agnostic to the way tokens are created. This means
  14 |     |  * that a supply mechanism has to be added in a derived contract using {_mint}.
  15 |     |  * For a generic mechanism see {ERC20PresetMinterPauser}.
  16 |     |  *
  17 |     |  * TIP: For a detailed writeup see our guide
  18 |     |  * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How
  19 |     |  * to implement supply mechanisms].
  20 |     |  *
  21 |     |  * The default value of {decimals} is 18. To change this, you should override
  22 |     |  * this function so it returns a different value.
  23 |     |  *
  24 |     |  * We have followed general OpenZeppelin Contracts guidelines: functions revert
  25 |     |  * instead returning `false` on failure. This behavior is nonetheless
  26 |     |  * conventional and does not conflict with the expectations of ERC20
  27 |     |  * applications.
  28 |     |  *
  29 |     |  * Additionally, an {Approval} event is emitted on calls to {transferFrom}.
  30 |     |  * This allows applications to reconstruct the allowance for all accounts just
  31 |     |  * by listening to said events. Other implementations of the EIP may not emit
  32 |     |  * these events, as it isn't required by the specification.
  33 |     |  *
  34 |     |  * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}
  35 |     |  * functions have been added to mitigate the well-known issues around setting
  36 |     |  * allowances. See {IERC20-approve}.
  37 |     |  */
  38 |     | contract ERC20 is Context, IERC20, IERC20Metadata {
  39 |     |     mapping(address => uint256) private _balances;
  40 |     | 
  41 |     |     mapping(address => mapping(address => uint256)) private _allowances;
  42 |     | 
  43 |     |     uint256 private _totalSupply;
  44 |     | 
  45 |     |     string private _name;
  46 |     |     string private _symbol;
  47 |     | 
  48 |     |     /**
  49 |     |      * @dev Sets the values for {name} and {symbol}.
  50 |     |      *
  51 |     |      * All two of these values are immutable: they can only be set once during
  52 |     |      * construction.
  53 |     |      */
  54 | *   |     constructor(string memory name_, string memory symbol_) {
  55 | *   |         _name = name_;
  56 | *   |         _symbol = symbol_;
  57 |     |     }
  58 |     | 
  59 |     |     /**
  60 |     |      * @dev Returns the name of the token.
  61 |     |      */
  62 |     |     function name() public view virtual override returns (string memory) {
  63 |     |         return _name;
  64 |     |     }
  65 |     | 
  66 |     |     /**
  67 |     |      * @dev Returns the symbol of the token, usually a shorter version of the
  68 |     |      * name.
  69 |     |      */
  70 |     |     function symbol() public view virtual override returns (string memory) {
  71 |     |         return _symbol;
  72 |     |     }
  73 |     | 
  74 |     |     /**
  75 |     |      * @dev Returns the number of decimals used to get its user representation.
  76 |     |      * For example, if `decimals` equals `2`, a balance of `505` tokens should
  77 |     |      * be displayed to a user as `5.05` (`505 / 10 ** 2`).
  78 |     |      *
  79 |     |      * Tokens usually opt for a value of 18, imitating the relationship between
  80 |     |      * Ether and Wei. This is the default value returned by this function, unless
  81 |     |      * it's overridden.
  82 |     |      *
  83 |     |      * NOTE: This information is only used for _display_ purposes: it in
  84 |     |      * no way affects any of the arithmetic of the contract, including
  85 |     |      * {IERC20-balanceOf} and {IERC20-transfer}.
  86 |     |      */
  87 |     |     function decimals() public view virtual override returns (uint8) {
  88 |     |         return 18;
  89 |     |     }
  90 |     | 
  91 |     |     /**
  92 |     |      * @dev See {IERC20-totalSupply}.
  93 |     |      */
  94 |     |     function totalSupply() public view virtual override returns (uint256) {
  95 |     |         return _totalSupply;
  96 |     |     }
  97 |     | 
  98 |     |     /**
  99 |     |      * @dev See {IERC20-balanceOf}.
 100 |     |      */
 101 | *   |     function balanceOf(address account) public view virtual override returns (uint256) {
 102 | *   |         return _balances[account];
 103 |     |     }
 104 |     | 
 105 |     |     /**
 106 |     |      * @dev See {IERC20-transfer}.
 107 |     |      *
 108 |     |      * Requirements:
 109 |     |      *
 110 |     |      * - `to` cannot be the zero address.
 111 |     |      * - the caller must have a balance of at least `amount`.
 112 |     |      */
 113 |     |     function transfer(address to, uint256 amount) public virtual override returns (bool) {
 114 |     |         address owner = _msgSender();
 115 |     |         _transfer(owner, to, amount);
 116 |     |         return true;
 117 |     |     }
 118 |     | 
 119 |     |     /**
 120 |     |      * @dev See {IERC20-allowance}.
 121 |     |      */
 122 | *   |     function allowance(address owner, address spender) public view virtual override returns (uint256) {
 123 | *   |         return _allowances[owner][spender];
 124 |     |     }
 125 |     | 
 126 |     |     /**
 127 |     |      * @dev See {IERC20-approve}.
 128 |     |      *
 129 |     |      * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on
 130 |     |      * `transferFrom`. This is semantically equivalent to an infinite approval.
 131 |     |      *
 132 |     |      * Requirements:
 133 |     |      *
 134 |     |      * - `spender` cannot be the zero address.
 135 |     |      */
 136 | *   |     function approve(address spender, uint256 amount) public virtual override returns (bool) {
 137 | *   |         address owner = _msgSender();
 138 | *   |         _approve(owner, spender, amount);
 139 | *   |         return true;
 140 |     |     }
 141 |     | 
 142 |     |     /**
 143 |     |      * @dev See {IERC20-transferFrom}.
 144 |     |      *
 145 |     |      * Emits an {Approval} event indicating the updated allowance. This is not
 146 |     |      * required by the EIP. See the note at the beginning of {ERC20}.
 147 |     |      *
 148 |     |      * NOTE: Does not update the allowance if the current allowance
 149 |     |      * is the maximum `uint256`.
 150 |     |      *
 151 |     |      * Requirements:
 152 |     |      *
 153 |     |      * - `from` and `to` cannot be the zero address.
 154 |     |      * - `from` must have a balance of at least `amount`.
 155 |     |      * - the caller must have allowance for ``from``'s tokens of at least
 156 |     |      * `amount`.
 157 |     |      */
 158 | *   |     function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {
 159 | *   |         address spender = _msgSender();
 160 | *   |         _spendAllowance(from, spender, amount);
 161 | *   |         _transfer(from, to, amount);
 162 | *   |         return true;
 163 |     |     }
 164 |     | 
 165 |     |     /**
 166 |     |      * @dev Atomically increases the allowance granted to `spender` by the caller.
 167 |     |      *
 168 |     |      * This is an alternative to {approve} that can be used as a mitigation for
 169 |     |      * problems described in {IERC20-approve}.
 170 |     |      *
 171 |     |      * Emits an {Approval} event indicating the updated allowance.
 172 |     |      *
 173 |     |      * Requirements:
 174 |     |      *
 175 |     |      * - `spender` cannot be the zero address.
 176 |     |      */
 177 |     |     function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {
 178 |     |         address owner = _msgSender();
 179 |     |         _approve(owner, spender, allowance(owner, spender) + addedValue);
 180 |     |         return true;
 181 |     |     }
 182 |     | 
 183 |     |     /**
 184 |     |      * @dev Atomically decreases the allowance granted to `spender` by the caller.
 185 |     |      *
 186 |     |      * This is an alternative to {approve} that can be used as a mitigation for
 187 |     |      * problems described in {IERC20-approve}.
 188 |     |      *
 189 |     |      * Emits an {Approval} event indicating the updated allowance.
 190 |     |      *
 191 |     |      * Requirements:
 192 |     |      *
 193 |     |      * - `spender` cannot be the zero address.
 194 |     |      * - `spender` must have allowance for the caller of at least
 195 |     |      * `subtractedValue`.
 196 |     |      */
 197 |     |     function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {
 198 |     |         address owner = _msgSender();
 199 |     |         uint256 currentAllowance = allowance(owner, spender);
 200 |     |         require(currentAllowance >= subtractedValue, "ERC20: decreased allowance below zero");
 201 |     |         unchecked {
 202 |     |             _approve(owner, spender, currentAllowance - subtractedValue);
 203 |     |         }
 204 |     | 
 205 |     |         return true;
 206 |     |     }
 207 |     | 
 208 |     |     /**
 209 |     |      * @dev Moves `amount` of tokens from `from` to `to`.
 210 |     |      *
 211 |     |      * This internal function is equivalent to {transfer}, and can be used to
 212 |     |      * e.g. implement automatic token fees, slashing mechanisms, etc.
 213 |     |      *
 214 |     |      * Emits a {Transfer} event.
 215 |     |      *
 216 |     |      * Requirements:
 217 |     |      *
 218 |     |      * - `from` cannot be the zero address.
 219 |     |      * - `to` cannot be the zero address.
 220 |     |      * - `from` must have a balance of at least `amount`.
 221 |     |      */
 222 | *   |     function _transfer(address from, address to, uint256 amount) internal virtual {
 223 | *   |         require(from != address(0), "ERC20: transfer from the zero address");
 224 | *   |         require(to != address(0), "ERC20: transfer to the zero address");
 225 |     | 
 226 | *   |         _beforeTokenTransfer(from, to, amount);
 227 |     | 
 228 | *   |         uint256 fromBalance = _balances[from];
 229 | *   |         require(fromBalance >= amount, "ERC20: transfer amount exceeds balance");
 230 |     |         unchecked {
 231 | *   |             _balances[from] = fromBalance - amount;
 232 |     |             // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by
 233 |     |             // decrementing then incrementing.
 234 | *   |             _balances[to] += amount;
 235 |     |         }
 236 |     | 
 237 | *   |         emit Transfer(from, to, amount);
 238 |     | 
 239 | *   |         _afterTokenTransfer(from, to, amount);
 240 |     |     }
 241 |     | 
 242 |     |     /** @dev Creates `amount` tokens and assigns them to `account`, increasing
 243 |     |      * the total supply.
 244 |     |      *
 245 |     |      * Emits a {Transfer} event with `from` set to the zero address.
 246 |     |      *
 247 |     |      * Requirements:
 248 |     |      *
 249 |     |      * - `account` cannot be the zero address.
 250 |     |      */
 251 | *   |     function _mint(address account, uint256 amount) internal virtual {
 252 | *   |         require(account != address(0), "ERC20: mint to the zero address");
 253 |     | 
 254 | *   |         _beforeTokenTransfer(address(0), account, amount);
 255 |     | 
 256 | *   |         _totalSupply += amount;
 257 |     |         unchecked {
 258 |     |             // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.
 259 | *   |             _balances[account] += amount;
 260 |     |         }
 261 | *   |         emit Transfer(address(0), account, amount);
 262 |     | 
 263 | *   |         _afterTokenTransfer(address(0), account, amount);
 264 |     |     }
 265 |     | 
 266 |     |     /**
 267 |     |      * @dev Destroys `amount` tokens from `account`, reducing the
 268 |     |      * total supply.
 269 |     |      *
 270 |     |      * Emits a {Transfer} event with `to` set to the zero address.
 271 |     |      *
 272 |     |      * Requirements:
 273 |     |      *
 274 |     |      * - `account` cannot be the zero address.
 275 |     |      * - `account` must have at least `amount` tokens.
 276 |     |      */
 277 |     |     function _burn(address account, uint256 amount) internal virtual {
 278 |     |         require(account != address(0), "ERC20: burn from the zero address");
 279 |     | 
 280 |     |         _beforeTokenTransfer(account, address(0), amount);
 281 |     | 
 282 |     |         uint256 accountBalance = _balances[account];
 283 |     |         require(accountBalance >= amount, "ERC20: burn amount exceeds balance");
 284 |     |         unchecked {
 285 |     |             _balances[account] = accountBalance - amount;
 286 |     |             // Overflow not possible: amount <= accountBalance <= totalSupply.
 287 |     |             _totalSupply -= amount;
 288 |     |         }
 289 |     | 
 290 |     |         emit Transfer(account, address(0), amount);
 291 |     | 
 292 |     |         _afterTokenTransfer(account, address(0), amount);
 293 |     |     }
 294 |     | 
 295 |     |     /**
 296 |     |      * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.
 297 |     |      *
 298 |     |      * This internal function is equivalent to `approve`, and can be used to
 299 |     |      * e.g. set automatic allowances for certain subsystems, etc.
 300 |     |      *
 301 |     |      * Emits an {Approval} event.
 302 |     |      *
 303 |     |      * Requirements:
 304 |     |      *
 305 |     |      * - `owner` cannot be the zero address.
 306 |     |      * - `spender` cannot be the zero address.
 307 |     |      */
 308 | *   |     function _approve(address owner, address spender, uint256 amount) internal virtual {
 309 | *   |         require(owner != address(0), "ERC20: approve from the zero address");
 310 | *   |         require(spender != address(0), "ERC20: approve to the zero address");
 311 |     | 
 312 | *   |         _allowances[owner][spender] = amount;
 313 | *   |         emit Approval(owner, spender, amount);
 314 |     |     }
 315 |     | 
 316 |     |     /**
 317 |     |      * @dev Updates `owner` s allowance for `spender` based on spent `amount`.
 318 |     |      *
 319 |     |      * Does not update the allowance amount in case of infinite allowance.
 320 |     |      * Revert if not enough allowance is available.
 321 |     |      *
 322 |     |      * Might emit an {Approval} event.
 323 |     |      */
 324 | *   |     function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {
 325 | *   |         uint256 currentAllowance = allowance(owner, spender);
 326 | *   |         if (currentAllowance != type(uint256).max) {
 327 | *   |             require(currentAllowance >= amount, "ERC20: insufficient allowance");
 328 |     |             unchecked {
 329 | *   |                 _approve(owner, spender, currentAllowance - amount);
 330 |     |             }
 331 |     |         }
 332 |     |     }
 333 |     | 
 334 |     |     /**
 335 |     |      * @dev Hook that is called before any transfer of tokens. This includes
 336 |     |      * minting and burning.
 337 |     |      *
 338 |     |      * Calling conditions:
 339 |     |      *
 340 |     |      * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens
 341 |     |      * will be transferred to `to`.
 342 |     |      * - when `from` is zero, `amount` tokens will be minted for `to`.
 343 |     |      * - when `to` is zero, `amount` of ``from``'s tokens will be burned.
 344 |     |      * - `from` and `to` are never both zero.
 345 |     |      *
 346 |     |      * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].
 347 |     |      */
 348 | *   |     function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}
 349 |     | 
 350 |     |     /**
 351 |     |      * @dev Hook that is called after any transfer of tokens. This includes
 352 |     |      * minting and burning.
 353 |     |      *
 354 |     |      * Calling conditions:
 355 |     |      *
 356 |     |      * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens
 357 |     |      * has been transferred to `to`.
 358 |     |      * - when `from` is zero, `amount` tokens have been minted for `to`.
 359 |     |      * - when `to` is zero, `amount` of ``from``'s tokens have been burned.
 360 |     |      * - `from` and `to` are never both zero.
 361 |     |      *
 362 |     |      * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].
 363 |     |      */
 364 | *   |     function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}
 365 |     | }
 366 |     | 

/mnt/c/Users/zerox/repos/bera.buzz-contracts/node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | /**
  7 |     |  * @dev Interface of the ERC20 standard as defined in the EIP.
  8 |     |  */
  9 |     | interface IERC20 {
 10 |     |     /**
 11 |     |      * @dev Emitted when `value` tokens are moved from one account (`from`) to
 12 |     |      * another (`to`).
 13 |     |      *
 14 |     |      * Note that `value` may be zero.
 15 |     |      */
 16 |     |     event Transfer(address indexed from, address indexed to, uint256 value);
 17 |     | 
 18 |     |     /**
 19 |     |      * @dev Emitted when the allowance of a `spender` for an `owner` is set by
 20 |     |      * a call to {approve}. `value` is the new allowance.
 21 |     |      */
 22 |     |     event Approval(address indexed owner, address indexed spender, uint256 value);
 23 |     | 
 24 |     |     /**
 25 |     |      * @dev Returns the amount of tokens in existence.
 26 |     |      */
 27 |     |     function totalSupply() external view returns (uint256);
 28 |     | 
 29 |     |     /**
 30 |     |      * @dev Returns the amount of tokens owned by `account`.
 31 |     |      */
 32 |     |     function balanceOf(address account) external view returns (uint256);
 33 |     | 
 34 |     |     /**
 35 |     |      * @dev Moves `amount` tokens from the caller's account to `to`.
 36 |     |      *
 37 |     |      * Returns a boolean value indicating whether the operation succeeded.
 38 |     |      *
 39 |     |      * Emits a {Transfer} event.
 40 |     |      */
 41 |     |     function transfer(address to, uint256 amount) external returns (bool);
 42 |     | 
 43 |     |     /**
 44 |     |      * @dev Returns the remaining number of tokens that `spender` will be
 45 |     |      * allowed to spend on behalf of `owner` through {transferFrom}. This is
 46 |     |      * zero by default.
 47 |     |      *
 48 |     |      * This value changes when {approve} or {transferFrom} are called.
 49 |     |      */
 50 |     |     function allowance(address owner, address spender) external view returns (uint256);
 51 |     | 
 52 |     |     /**
 53 |     |      * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
 54 |     |      *
 55 |     |      * Returns a boolean value indicating whether the operation succeeded.
 56 |     |      *
 57 |     |      * IMPORTANT: Beware that changing an allowance with this method brings the risk
 58 |     |      * that someone may use both the old and the new allowance by unfortunate
 59 |     |      * transaction ordering. One possible solution to mitigate this race
 60 |     |      * condition is to first reduce the spender's allowance to 0 and set the
 61 |     |      * desired value afterwards:
 62 |     |      * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
 63 |     |      *
 64 |     |      * Emits an {Approval} event.
 65 |     |      */
 66 |     |     function approve(address spender, uint256 amount) external returns (bool);
 67 |     | 
 68 |     |     /**
 69 |     |      * @dev Moves `amount` tokens from `from` to `to` using the
 70 |     |      * allowance mechanism. `amount` is then deducted from the caller's
 71 |     |      * allowance.
 72 |     |      *
 73 |     |      * Returns a boolean value indicating whether the operation succeeded.
 74 |     |      *
 75 |     |      * Emits a {Transfer} event.
 76 |     |      */
 77 |     |     function transferFrom(address from, address to, uint256 amount) external returns (bool);
 78 |     | }
 79 |     | 

/mnt/c/Users/zerox/repos/bera.buzz-contracts/node_modules/@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | import "../IERC20.sol";
  7 |     | 
  8 |     | /**
  9 |     |  * @dev Interface for the optional metadata functions from the ERC20 standard.
 10 |     |  *
 11 |     |  * _Available since v4.1._
 12 |     |  */
 13 |     | interface IERC20Metadata is IERC20 {
 14 |     |     /**
 15 |     |      * @dev Returns the name of the token.
 16 |     |      */
 17 |     |     function name() external view returns (string memory);
 18 |     | 
 19 |     |     /**
 20 |     |      * @dev Returns the symbol of the token.
 21 |     |      */
 22 |     |     function symbol() external view returns (string memory);
 23 |     | 
 24 |     |     /**
 25 |     |      * @dev Returns the decimals places of the token.
 26 |     |      */
 27 |     |     function decimals() external view returns (uint8);
 28 |     | }
 29 |     | 

/mnt/c/Users/zerox/repos/bera.buzz-contracts/node_modules/@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v4.9.4) (token/ERC20/extensions/IERC20Permit.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | /**
  7 |     |  * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in
  8 |     |  * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].
  9 |     |  *
 10 |     |  * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by
 11 |     |  * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't
 12 |     |  * need to send a transaction, and thus is not required to hold Ether at all.
 13 |     |  *
 14 |     |  * ==== Security Considerations
 15 |     |  *
 16 |     |  * There are two important considerations concerning the use of `permit`. The first is that a valid permit signature
 17 |     |  * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be
 18 |     |  * considered as an intention to spend the allowance in any specific way. The second is that because permits have
 19 |     |  * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should
 20 |     |  * take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be
 21 |     |  * generally recommended is:
 22 |     |  *
 23 |     |  * ```solidity
 24 |     |  * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {
 25 |     |  *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}
 26 |     |  *     doThing(..., value);
 27 |     |  * }
 28 |     |  *
 29 |     |  * function doThing(..., uint256 value) public {
 30 |     |  *     token.safeTransferFrom(msg.sender, address(this), value);
 31 |     |  *     ...
 32 |     |  * }
 33 |     |  * ```
 34 |     |  *
 35 |     |  * Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of
 36 |     |  * `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also
 37 |     |  * {SafeERC20-safeTransferFrom}).
 38 |     |  *
 39 |     |  * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so
 40 |     |  * contracts should have entry points that don't rely on permit.
 41 |     |  */
 42 |     | interface IERC20Permit {
 43 |     |     /**
 44 |     |      * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,
 45 |     |      * given ``owner``'s signed approval.
 46 |     |      *
 47 |     |      * IMPORTANT: The same issues {IERC20-approve} has related to transaction
 48 |     |      * ordering also apply here.
 49 |     |      *
 50 |     |      * Emits an {Approval} event.
 51 |     |      *
 52 |     |      * Requirements:
 53 |     |      *
 54 |     |      * - `spender` cannot be the zero address.
 55 |     |      * - `deadline` must be a timestamp in the future.
 56 |     |      * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`
 57 |     |      * over the EIP712-formatted function arguments.
 58 |     |      * - the signature must use ``owner``'s current nonce (see {nonces}).
 59 |     |      *
 60 |     |      * For more information on the signature format, see the
 61 |     |      * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP
 62 |     |      * section].
 63 |     |      *
 64 |     |      * CAUTION: See Security Considerations above.
 65 |     |      */
 66 |     |     function permit(
 67 |     |         address owner,
 68 |     |         address spender,
 69 |     |         uint256 value,
 70 |     |         uint256 deadline,
 71 |     |         uint8 v,
 72 |     |         bytes32 r,
 73 |     |         bytes32 s
 74 |     |     ) external;
 75 |     | 
 76 |     |     /**
 77 |     |      * @dev Returns the current nonce for `owner`. This value must be
 78 |     |      * included whenever a signature is generated for {permit}.
 79 |     |      *
 80 |     |      * Every successful call to {permit} increases ``owner``'s nonce by one. This
 81 |     |      * prevents a signature from being used multiple times.
 82 |     |      */
 83 |     |     function nonces(address owner) external view returns (uint256);
 84 |     | 
 85 |     |     /**
 86 |     |      * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.
 87 |     |      */
 88 |     |     // solhint-disable-next-line func-name-mixedcase
 89 |     |     function DOMAIN_SEPARATOR() external view returns (bytes32);
 90 |     | }
 91 |     | 

/mnt/c/Users/zerox/repos/bera.buzz-contracts/node_modules/@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v4.9.3) (token/ERC20/utils/SafeERC20.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.0;
   5 |     | 
   6 |     | import "../IERC20.sol";
   7 |     | import "../extensions/IERC20Permit.sol";
   8 |     | import "../../../utils/Address.sol";
   9 |     | 
  10 |     | /**
  11 |     |  * @title SafeERC20
  12 |     |  * @dev Wrappers around ERC20 operations that throw on failure (when the token
  13 |     |  * contract returns false). Tokens that return no value (and instead revert or
  14 |     |  * throw on failure) are also supported, non-reverting calls are assumed to be
  15 |     |  * successful.
  16 |     |  * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,
  17 |     |  * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.
  18 |     |  */
  19 |     | library SafeERC20 {
  20 |     |     using Address for address;
  21 |     | 
  22 |     |     /**
  23 |     |      * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,
  24 |     |      * non-reverting calls are assumed to be successful.
  25 |     |      */
  26 |     |     function safeTransfer(IERC20 token, address to, uint256 value) internal {
  27 |     |         _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));
  28 |     |     }
  29 |     | 
  30 |     |     /**
  31 |     |      * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the
  32 |     |      * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.
  33 |     |      */
  34 | *   |     function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {
  35 | *   |         _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));
  36 |     |     }
  37 |     | 
  38 |     |     /**
  39 |     |      * @dev Deprecated. This function has issues similar to the ones found in
  40 |     |      * {IERC20-approve}, and its usage is discouraged.
  41 |     |      *
  42 |     |      * Whenever possible, use {safeIncreaseAllowance} and
  43 |     |      * {safeDecreaseAllowance} instead.
  44 |     |      */
  45 | *   |     function safeApprove(IERC20 token, address spender, uint256 value) internal {
  46 |     |         // safeApprove should only be called when setting an initial allowance,
  47 |     |         // or when resetting it to zero. To increase and decrease it, use
  48 |     |         // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'
  49 | *   |         require(
  50 | *   |             (value == 0) || (token.allowance(address(this), spender) == 0),
  51 |     |             "SafeERC20: approve from non-zero to non-zero allowance"
  52 |     |         );
  53 | *   |         _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));
  54 |     |     }
  55 |     | 
  56 |     |     /**
  57 |     |      * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,
  58 |     |      * non-reverting calls are assumed to be successful.
  59 |     |      */
  60 |     |     function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {
  61 |     |         uint256 oldAllowance = token.allowance(address(this), spender);
  62 |     |         _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));
  63 |     |     }
  64 |     | 
  65 |     |     /**
  66 |     |      * @dev Decrease the calling contract's allowance toward `spender` by `value`. If `token` returns no value,
  67 |     |      * non-reverting calls are assumed to be successful.
  68 |     |      */
  69 |     |     function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {
  70 |     |         unchecked {
  71 |     |             uint256 oldAllowance = token.allowance(address(this), spender);
  72 |     |             require(oldAllowance >= value, "SafeERC20: decreased allowance below zero");
  73 |     |             _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));
  74 |     |         }
  75 |     |     }
  76 |     | 
  77 |     |     /**
  78 |     |      * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,
  79 |     |      * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval
  80 |     |      * to be set to zero before setting it to a non-zero value, such as USDT.
  81 |     |      */
  82 |     |     function forceApprove(IERC20 token, address spender, uint256 value) internal {
  83 |     |         bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);
  84 |     | 
  85 |     |         if (!_callOptionalReturnBool(token, approvalCall)) {
  86 |     |             _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));
  87 |     |             _callOptionalReturn(token, approvalCall);
  88 |     |         }
  89 |     |     }
  90 |     | 
  91 |     |     /**
  92 |     |      * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.
  93 |     |      * Revert on invalid signature.
  94 |     |      */
  95 |     |     function safePermit(
  96 |     |         IERC20Permit token,
  97 |     |         address owner,
  98 |     |         address spender,
  99 |     |         uint256 value,
 100 |     |         uint256 deadline,
 101 |     |         uint8 v,
 102 |     |         bytes32 r,
 103 |     |         bytes32 s
 104 |     |     ) internal {
 105 |     |         uint256 nonceBefore = token.nonces(owner);
 106 |     |         token.permit(owner, spender, value, deadline, v, r, s);
 107 |     |         uint256 nonceAfter = token.nonces(owner);
 108 |     |         require(nonceAfter == nonceBefore + 1, "SafeERC20: permit did not succeed");
 109 |     |     }
 110 |     | 
 111 |     |     /**
 112 |     |      * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement
 113 |     |      * on the return value: the return value is optional (but if data is returned, it must not be false).
 114 |     |      * @param token The token targeted by the call.
 115 |     |      * @param data The call data (encoded using abi.encode or one of its variants).
 116 |     |      */
 117 | *   |     function _callOptionalReturn(IERC20 token, bytes memory data) private {
 118 |     |         // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since
 119 |     |         // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that
 120 |     |         // the target address contains contract code and also asserts for success in the low-level call.
 121 |     | 
 122 | *   |         bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");
 123 | *   |         require(returndata.length == 0 || abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");
 124 |     |     }
 125 |     | 
 126 |     |     /**
 127 |     |      * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement
 128 |     |      * on the return value: the return value is optional (but if data is returned, it must not be false).
 129 |     |      * @param token The token targeted by the call.
 130 |     |      * @param data The call data (encoded using abi.encode or one of its variants).
 131 |     |      *
 132 |     |      * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.
 133 |     |      */
 134 |     |     function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {
 135 |     |         // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since
 136 |     |         // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false
 137 |     |         // and not revert is the subcall reverts.
 138 |     | 
 139 |     |         (bool success, bytes memory returndata) = address(token).call(data);
 140 |     |         return
 141 |     |             success && (returndata.length == 0 || abi.decode(returndata, (bool))) && Address.isContract(address(token));
 142 |     |     }
 143 |     | }
 144 |     | 

/mnt/c/Users/zerox/repos/bera.buzz-contracts/node_modules/@openzeppelin/contracts/utils/Address.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.1;
   5 |     | 
   6 |     | /**
   7 |     |  * @dev Collection of functions related to the address type
   8 |     |  */
   9 |     | library Address {
  10 |     |     /**
  11 |     |      * @dev Returns true if `account` is a contract.
  12 |     |      *
  13 |     |      * [IMPORTANT]
  14 |     |      * ====
  15 |     |      * It is unsafe to assume that an address for which this function returns
  16 |     |      * false is an externally-owned account (EOA) and not a contract.
  17 |     |      *
  18 |     |      * Among others, `isContract` will return false for the following
  19 |     |      * types of addresses:
  20 |     |      *
  21 |     |      *  - an externally-owned account
  22 |     |      *  - a contract in construction
  23 |     |      *  - an address where a contract will be created
  24 |     |      *  - an address where a contract lived, but was destroyed
  25 |     |      *
  26 |     |      * Furthermore, `isContract` will also return true if the target contract within
  27 |     |      * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,
  28 |     |      * which only has an effect at the end of a transaction.
  29 |     |      * ====
  30 |     |      *
  31 |     |      * [IMPORTANT]
  32 |     |      * ====
  33 |     |      * You shouldn't rely on `isContract` to protect against flash loan attacks!
  34 |     |      *
  35 |     |      * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets
  36 |     |      * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract
  37 |     |      * constructor.
  38 |     |      * ====
  39 |     |      */
  40 |     |     function isContract(address account) internal view returns (bool) {
  41 |     |         // This method relies on extcodesize/address.code.length, which returns 0
  42 |     |         // for contracts in construction, since the code is only stored at the end
  43 |     |         // of the constructor execution.
  44 |     | 
  45 |     |         return account.code.length > 0;
  46 |     |     }
  47 |     | 
  48 |     |     /**
  49 |     |      * @dev Replacement for Solidity's `transfer`: sends `amount` wei to
  50 |     |      * `recipient`, forwarding all available gas and reverting on errors.
  51 |     |      *
  52 |     |      * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost
  53 |     |      * of certain opcodes, possibly making contracts go over the 2300 gas limit
  54 |     |      * imposed by `transfer`, making them unable to receive funds via
  55 |     |      * `transfer`. {sendValue} removes this limitation.
  56 |     |      *
  57 |     |      * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].
  58 |     |      *
  59 |     |      * IMPORTANT: because control is transferred to `recipient`, care must be
  60 |     |      * taken to not create reentrancy vulnerabilities. Consider using
  61 |     |      * {ReentrancyGuard} or the
  62 |     |      * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].
  63 |     |      */
  64 |     |     function sendValue(address payable recipient, uint256 amount) internal {
  65 |     |         require(address(this).balance >= amount, "Address: insufficient balance");
  66 |     | 
  67 |     |         (bool success, ) = recipient.call{value: amount}("");
  68 |     |         require(success, "Address: unable to send value, recipient may have reverted");
  69 |     |     }
  70 |     | 
  71 |     |     /**
  72 |     |      * @dev Performs a Solidity function call using a low level `call`. A
  73 |     |      * plain `call` is an unsafe replacement for a function call: use this
  74 |     |      * function instead.
  75 |     |      *
  76 |     |      * If `target` reverts with a revert reason, it is bubbled up by this
  77 |     |      * function (like regular Solidity function calls).
  78 |     |      *
  79 |     |      * Returns the raw returned data. To convert to the expected return value,
  80 |     |      * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].
  81 |     |      *
  82 |     |      * Requirements:
  83 |     |      *
  84 |     |      * - `target` must be a contract.
  85 |     |      * - calling `target` with `data` must not revert.
  86 |     |      *
  87 |     |      * _Available since v3.1._
  88 |     |      */
  89 |     |     function functionCall(address target, bytes memory data) internal returns (bytes memory) {
  90 |     |         return functionCallWithValue(target, data, 0, "Address: low-level call failed");
  91 |     |     }
  92 |     | 
  93 |     |     /**
  94 |     |      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with
  95 |     |      * `errorMessage` as a fallback revert reason when `target` reverts.
  96 |     |      *
  97 |     |      * _Available since v3.1._
  98 |     |      */
  99 | *   |     function functionCall(
 100 |     |         address target,
 101 |     |         bytes memory data,
 102 |     |         string memory errorMessage
 103 | *   |     ) internal returns (bytes memory) {
 104 | *   |         return functionCallWithValue(target, data, 0, errorMessage);
 105 |     |     }
 106 |     | 
 107 |     |     /**
 108 |     |      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
 109 |     |      * but also transferring `value` wei to `target`.
 110 |     |      *
 111 |     |      * Requirements:
 112 |     |      *
 113 |     |      * - the calling contract must have an ETH balance of at least `value`.
 114 |     |      * - the called Solidity function must be `payable`.
 115 |     |      *
 116 |     |      * _Available since v3.1._
 117 |     |      */
 118 |     |     function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {
 119 |     |         return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
 120 |     |     }
 121 |     | 
 122 |     |     /**
 123 |     |      * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but
 124 |     |      * with `errorMessage` as a fallback revert reason when `target` reverts.
 125 |     |      *
 126 |     |      * _Available since v3.1._
 127 |     |      */
 128 | *   |     function functionCallWithValue(
 129 |     |         address target,
 130 |     |         bytes memory data,
 131 |     |         uint256 value,
 132 |     |         string memory errorMessage
 133 | *   |     ) internal returns (bytes memory) {
 134 | *   |         require(address(this).balance >= value, "Address: insufficient balance for call");
 135 | *   |         (bool success, bytes memory returndata) = target.call{value: value}(data);
 136 | *   |         return verifyCallResultFromTarget(target, success, returndata, errorMessage);
 137 |     |     }
 138 |     | 
 139 |     |     /**
 140 |     |      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
 141 |     |      * but performing a static call.
 142 |     |      *
 143 |     |      * _Available since v3.3._
 144 |     |      */
 145 |     |     function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
 146 |     |         return functionStaticCall(target, data, "Address: low-level static call failed");
 147 |     |     }
 148 |     | 
 149 |     |     /**
 150 |     |      * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],
 151 |     |      * but performing a static call.
 152 |     |      *
 153 |     |      * _Available since v3.3._
 154 |     |      */
 155 |     |     function functionStaticCall(
 156 |     |         address target,
 157 |     |         bytes memory data,
 158 |     |         string memory errorMessage
 159 |     |     ) internal view returns (bytes memory) {
 160 |     |         (bool success, bytes memory returndata) = target.staticcall(data);
 161 |     |         return verifyCallResultFromTarget(target, success, returndata, errorMessage);
 162 |     |     }
 163 |     | 
 164 |     |     /**
 165 |     |      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
 166 |     |      * but performing a delegate call.
 167 |     |      *
 168 |     |      * _Available since v3.4._
 169 |     |      */
 170 |     |     function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {
 171 |     |         return functionDelegateCall(target, data, "Address: low-level delegate call failed");
 172 |     |     }
 173 |     | 
 174 |     |     /**
 175 |     |      * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],
 176 |     |      * but performing a delegate call.
 177 |     |      *
 178 |     |      * _Available since v3.4._
 179 |     |      */
 180 |     |     function functionDelegateCall(
 181 |     |         address target,
 182 |     |         bytes memory data,
 183 |     |         string memory errorMessage
 184 |     |     ) internal returns (bytes memory) {
 185 |     |         (bool success, bytes memory returndata) = target.delegatecall(data);
 186 |     |         return verifyCallResultFromTarget(target, success, returndata, errorMessage);
 187 |     |     }
 188 |     | 
 189 |     |     /**
 190 |     |      * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling
 191 |     |      * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.
 192 |     |      *
 193 |     |      * _Available since v4.8._
 194 |     |      */
 195 | *   |     function verifyCallResultFromTarget(
 196 |     |         address target,
 197 |     |         bool success,
 198 |     |         bytes memory returndata,
 199 |     |         string memory errorMessage
 200 | *   |     ) internal view returns (bytes memory) {
 201 | *   |         if (success) {
 202 | *   |             if (returndata.length == 0) {
 203 |     |                 // only check isContract if the call was successful and the return data is empty
 204 |     |                 // otherwise we already know that it was a contract
 205 |     |                 require(isContract(target), "Address: call to non-contract");
 206 |     |             }
 207 | *   |             return returndata;
 208 |     |         } else {
 209 |     |             _revert(returndata, errorMessage);
 210 |     |         }
 211 |     |     }
 212 |     | 
 213 |     |     /**
 214 |     |      * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the
 215 |     |      * revert reason or using the provided one.
 216 |     |      *
 217 |     |      * _Available since v4.3._
 218 |     |      */
 219 |     |     function verifyCallResult(
 220 |     |         bool success,
 221 |     |         bytes memory returndata,
 222 |     |         string memory errorMessage
 223 |     |     ) internal pure returns (bytes memory) {
 224 |     |         if (success) {
 225 |     |             return returndata;
 226 |     |         } else {
 227 |     |             _revert(returndata, errorMessage);
 228 |     |         }
 229 |     |     }
 230 |     | 
 231 |     |     function _revert(bytes memory returndata, string memory errorMessage) private pure {
 232 |     |         // Look for revert reason and bubble it up if present
 233 |     |         if (returndata.length > 0) {
 234 |     |             // The easiest way to bubble the revert reason is using memory via assembly
 235 |     |             /// @solidity memory-safe-assembly
 236 |     |             assembly {
 237 |     |                 let returndata_size := mload(returndata)
 238 |     |                 revert(add(32, returndata), returndata_size)
 239 |     |             }
 240 |     |         } else {
 241 |     |             revert(errorMessage);
 242 |     |         }
 243 |     |     }
 244 |     | }
 245 |     | 

/mnt/c/Users/zerox/repos/bera.buzz-contracts/node_modules/@openzeppelin/contracts/utils/Context.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v4.9.4) (utils/Context.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | /**
  7 |     |  * @dev Provides information about the current execution context, including the
  8 |     |  * sender of the transaction and its data. While these are generally available
  9 |     |  * via msg.sender and msg.data, they should not be accessed in such a direct
 10 |     |  * manner, since when dealing with meta-transactions the account sending and
 11 |     |  * paying for execution may not be the actual sender (as far as an application
 12 |     |  * is concerned).
 13 |     |  *
 14 |     |  * This contract is only required for intermediate, library-like contracts.
 15 |     |  */
 16 |     | abstract contract Context {
 17 | *   |     function _msgSender() internal view virtual returns (address) {
 18 | *   |         return msg.sender;
 19 |     |     }
 20 |     | 
 21 |     |     function _msgData() internal view virtual returns (bytes calldata) {
 22 |     |         return msg.data;
 23 |     |     }
 24 |     | 
 25 |     |     function _contextSuffixLength() internal view virtual returns (uint256) {
 26 |     |         return 0;
 27 |     |     }
 28 |     | }
 29 |     | 

/mnt/c/Users/zerox/repos/bera.buzz-contracts/node_modules/@openzeppelin/contracts/utils/Strings.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v4.9.0) (utils/Strings.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | import "./math/Math.sol";
  7 |     | import "./math/SignedMath.sol";
  8 |     | 
  9 |     | /**
 10 |     |  * @dev String operations.
 11 |     |  */
 12 |     | library Strings {
 13 |     |     bytes16 private constant _SYMBOLS = "0123456789abcdef";
 14 |     |     uint8 private constant _ADDRESS_LENGTH = 20;
 15 |     | 
 16 |     |     /**
 17 |     |      * @dev Converts a `uint256` to its ASCII `string` decimal representation.
 18 |     |      */
 19 |     |     function toString(uint256 value) internal pure returns (string memory) {
 20 |     |         unchecked {
 21 |     |             uint256 length = Math.log10(value) + 1;
 22 |     |             string memory buffer = new string(length);
 23 |     |             uint256 ptr;
 24 |     |             /// @solidity memory-safe-assembly
 25 |     |             assembly {
 26 |     |                 ptr := add(buffer, add(32, length))
 27 |     |             }
 28 |     |             while (true) {
 29 |     |                 ptr--;
 30 |     |                 /// @solidity memory-safe-assembly
 31 |     |                 assembly {
 32 |     |                     mstore8(ptr, byte(mod(value, 10), _SYMBOLS))
 33 |     |                 }
 34 |     |                 value /= 10;
 35 |     |                 if (value == 0) break;
 36 |     |             }
 37 |     |             return buffer;
 38 |     |         }
 39 |     |     }
 40 |     | 
 41 |     |     /**
 42 |     |      * @dev Converts a `int256` to its ASCII `string` decimal representation.
 43 |     |      */
 44 |     |     function toString(int256 value) internal pure returns (string memory) {
 45 |     |         return string(abi.encodePacked(value < 0 ? "-" : "", toString(SignedMath.abs(value))));
 46 |     |     }
 47 |     | 
 48 |     |     /**
 49 |     |      * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.
 50 |     |      */
 51 |     |     function toHexString(uint256 value) internal pure returns (string memory) {
 52 |     |         unchecked {
 53 |     |             return toHexString(value, Math.log256(value) + 1);
 54 |     |         }
 55 |     |     }
 56 |     | 
 57 |     |     /**
 58 |     |      * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.
 59 |     |      */
 60 |     |     function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {
 61 |     |         bytes memory buffer = new bytes(2 * length + 2);
 62 |     |         buffer[0] = "0";
 63 |     |         buffer[1] = "x";
 64 |     |         for (uint256 i = 2 * length + 1; i > 1; --i) {
 65 |     |             buffer[i] = _SYMBOLS[value & 0xf];
 66 |     |             value >>= 4;
 67 |     |         }
 68 |     |         require(value == 0, "Strings: hex length insufficient");
 69 |     |         return string(buffer);
 70 |     |     }
 71 |     | 
 72 |     |     /**
 73 |     |      * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.
 74 |     |      */
 75 |     |     function toHexString(address addr) internal pure returns (string memory) {
 76 |     |         return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);
 77 |     |     }
 78 |     | 
 79 |     |     /**
 80 |     |      * @dev Returns true if the two strings are equal.
 81 |     |      */
 82 |     |     function equal(string memory a, string memory b) internal pure returns (bool) {
 83 |     |         return keccak256(bytes(a)) == keccak256(bytes(b));
 84 |     |     }
 85 |     | }
 86 |     | 

/mnt/c/Users/zerox/repos/bera.buzz-contracts/node_modules/@openzeppelin/contracts/utils/introspection/ERC165.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | import "./IERC165.sol";
  7 |     | 
  8 |     | /**
  9 |     |  * @dev Implementation of the {IERC165} interface.
 10 |     |  *
 11 |     |  * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check
 12 |     |  * for the additional interface id that will be supported. For example:
 13 |     |  *
 14 |     |  * ```solidity
 15 |     |  * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
 16 |     |  *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);
 17 |     |  * }
 18 |     |  * ```
 19 |     |  *
 20 |     |  * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.
 21 |     |  */
 22 |     | abstract contract ERC165 is IERC165 {
 23 |     |     /**
 24 |     |      * @dev See {IERC165-supportsInterface}.
 25 |     |      */
 26 |     |     function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
 27 |     |         return interfaceId == type(IERC165).interfaceId;
 28 |     |     }
 29 |     | }
 30 |     | 

/mnt/c/Users/zerox/repos/bera.buzz-contracts/node_modules/@openzeppelin/contracts/utils/introspection/IERC165.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | /**
  7 |     |  * @dev Interface of the ERC165 standard, as defined in the
  8 |     |  * https://eips.ethereum.org/EIPS/eip-165[EIP].
  9 |     |  *
 10 |     |  * Implementers can declare support of contract interfaces, which can then be
 11 |     |  * queried by others ({ERC165Checker}).
 12 |     |  *
 13 |     |  * For an implementation, see {ERC165}.
 14 |     |  */
 15 |     | interface IERC165 {
 16 |     |     /**
 17 |     |      * @dev Returns true if this contract implements the interface defined by
 18 |     |      * `interfaceId`. See the corresponding
 19 |     |      * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]
 20 |     |      * to learn more about how these ids are created.
 21 |     |      *
 22 |     |      * This function call must use less than 30 000 gas.
 23 |     |      */
 24 |     |     function supportsInterface(bytes4 interfaceId) external view returns (bool);
 25 |     | }
 26 |     | 

/mnt/c/Users/zerox/repos/bera.buzz-contracts/node_modules/@openzeppelin/contracts/utils/math/Math.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.0;
   5 |     | 
   6 |     | /**
   7 |     |  * @dev Standard math utilities missing in the Solidity language.
   8 |     |  */
   9 |     | library Math {
  10 |     |     enum Rounding {
  11 |     |         Down, // Toward negative infinity
  12 |     |         Up, // Toward infinity
  13 |     |         Zero // Toward zero
  14 |     |     }
  15 |     | 
  16 |     |     /**
  17 |     |      * @dev Returns the largest of two numbers.
  18 |     |      */
  19 |     |     function max(uint256 a, uint256 b) internal pure returns (uint256) {
  20 |     |         return a > b ? a : b;
  21 |     |     }
  22 |     | 
  23 |     |     /**
  24 |     |      * @dev Returns the smallest of two numbers.
  25 |     |      */
  26 |     |     function min(uint256 a, uint256 b) internal pure returns (uint256) {
  27 |     |         return a < b ? a : b;
  28 |     |     }
  29 |     | 
  30 |     |     /**
  31 |     |      * @dev Returns the average of two numbers. The result is rounded towards
  32 |     |      * zero.
  33 |     |      */
  34 |     |     function average(uint256 a, uint256 b) internal pure returns (uint256) {
  35 |     |         // (a + b) / 2 can overflow.
  36 |     |         return (a & b) + (a ^ b) / 2;
  37 |     |     }
  38 |     | 
  39 |     |     /**
  40 |     |      * @dev Returns the ceiling of the division of two numbers.
  41 |     |      *
  42 |     |      * This differs from standard division with `/` in that it rounds up instead
  43 |     |      * of rounding down.
  44 |     |      */
  45 |     |     function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {
  46 |     |         // (a + b - 1) / b can overflow on addition, so we distribute.
  47 |     |         return a == 0 ? 0 : (a - 1) / b + 1;
  48 |     |     }
  49 |     | 
  50 |     |     /**
  51 |     |      * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0
  52 |     |      * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)
  53 |     |      * with further edits by Uniswap Labs also under MIT license.
  54 |     |      */
  55 |     |     function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {
  56 |     |         unchecked {
  57 |     |             // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use
  58 |     |             // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256
  59 |     |             // variables such that product = prod1 * 2^256 + prod0.
  60 |     |             uint256 prod0; // Least significant 256 bits of the product
  61 |     |             uint256 prod1; // Most significant 256 bits of the product
  62 |     |             assembly {
  63 |     |                 let mm := mulmod(x, y, not(0))
  64 |     |                 prod0 := mul(x, y)
  65 |     |                 prod1 := sub(sub(mm, prod0), lt(mm, prod0))
  66 |     |             }
  67 |     | 
  68 |     |             // Handle non-overflow cases, 256 by 256 division.
  69 |     |             if (prod1 == 0) {
  70 |     |                 // Solidity will revert if denominator == 0, unlike the div opcode on its own.
  71 |     |                 // The surrounding unchecked block does not change this fact.
  72 |     |                 // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.
  73 |     |                 return prod0 / denominator;
  74 |     |             }
  75 |     | 
  76 |     |             // Make sure the result is less than 2^256. Also prevents denominator == 0.
  77 |     |             require(denominator > prod1, "Math: mulDiv overflow");
  78 |     | 
  79 |     |             ///////////////////////////////////////////////
  80 |     |             // 512 by 256 division.
  81 |     |             ///////////////////////////////////////////////
  82 |     | 
  83 |     |             // Make division exact by subtracting the remainder from [prod1 prod0].
  84 |     |             uint256 remainder;
  85 |     |             assembly {
  86 |     |                 // Compute remainder using mulmod.
  87 |     |                 remainder := mulmod(x, y, denominator)
  88 |     | 
  89 |     |                 // Subtract 256 bit number from 512 bit number.
  90 |     |                 prod1 := sub(prod1, gt(remainder, prod0))
  91 |     |                 prod0 := sub(prod0, remainder)
  92 |     |             }
  93 |     | 
  94 |     |             // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.
  95 |     |             // See https://cs.stackexchange.com/q/138556/92363.
  96 |     | 
  97 |     |             // Does not overflow because the denominator cannot be zero at this stage in the function.
  98 |     |             uint256 twos = denominator & (~denominator + 1);
  99 |     |             assembly {
 100 |     |                 // Divide denominator by twos.
 101 |     |                 denominator := div(denominator, twos)
 102 |     | 
 103 |     |                 // Divide [prod1 prod0] by twos.
 104 |     |                 prod0 := div(prod0, twos)
 105 |     | 
 106 |     |                 // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.
 107 |     |                 twos := add(div(sub(0, twos), twos), 1)
 108 |     |             }
 109 |     | 
 110 |     |             // Shift in bits from prod1 into prod0.
 111 |     |             prod0 |= prod1 * twos;
 112 |     | 
 113 |     |             // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such
 114 |     |             // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for
 115 |     |             // four bits. That is, denominator * inv = 1 mod 2^4.
 116 |     |             uint256 inverse = (3 * denominator) ^ 2;
 117 |     | 
 118 |     |             // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works
 119 |     |             // in modular arithmetic, doubling the correct bits in each step.
 120 |     |             inverse *= 2 - denominator * inverse; // inverse mod 2^8
 121 |     |             inverse *= 2 - denominator * inverse; // inverse mod 2^16
 122 |     |             inverse *= 2 - denominator * inverse; // inverse mod 2^32
 123 |     |             inverse *= 2 - denominator * inverse; // inverse mod 2^64
 124 |     |             inverse *= 2 - denominator * inverse; // inverse mod 2^128
 125 |     |             inverse *= 2 - denominator * inverse; // inverse mod 2^256
 126 |     | 
 127 |     |             // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.
 128 |     |             // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is
 129 |     |             // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1
 130 |     |             // is no longer required.
 131 |     |             result = prod0 * inverse;
 132 |     |             return result;
 133 |     |         }
 134 |     |     }
 135 |     | 
 136 |     |     /**
 137 |     |      * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.
 138 |     |      */
 139 |     |     function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {
 140 |     |         uint256 result = mulDiv(x, y, denominator);
 141 |     |         if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {
 142 |     |             result += 1;
 143 |     |         }
 144 |     |         return result;
 145 |     |     }
 146 |     | 
 147 |     |     /**
 148 |     |      * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.
 149 |     |      *
 150 |     |      * Inspired by Henry S. Warren, Jr.'s "Hacker's Delight" (Chapter 11).
 151 |     |      */
 152 |     |     function sqrt(uint256 a) internal pure returns (uint256) {
 153 |     |         if (a == 0) {
 154 |     |             return 0;
 155 |     |         }
 156 |     | 
 157 |     |         // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.
 158 |     |         //
 159 |     |         // We know that the "msb" (most significant bit) of our target number `a` is a power of 2 such that we have
 160 |     |         // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.
 161 |     |         //
 162 |     |         // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`
 163 |     |         // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`
 164 |     |         // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`
 165 |     |         //
 166 |     |         // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.
 167 |     |         uint256 result = 1 << (log2(a) >> 1);
 168 |     | 
 169 |     |         // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,
 170 |     |         // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at
 171 |     |         // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision
 172 |     |         // into the expected uint128 result.
 173 |     |         unchecked {
 174 |     |             result = (result + a / result) >> 1;
 175 |     |             result = (result + a / result) >> 1;
 176 |     |             result = (result + a / result) >> 1;
 177 |     |             result = (result + a / result) >> 1;
 178 |     |             result = (result + a / result) >> 1;
 179 |     |             result = (result + a / result) >> 1;
 180 |     |             result = (result + a / result) >> 1;
 181 |     |             return min(result, a / result);
 182 |     |         }
 183 |     |     }
 184 |     | 
 185 |     |     /**
 186 |     |      * @notice Calculates sqrt(a), following the selected rounding direction.
 187 |     |      */
 188 |     |     function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {
 189 |     |         unchecked {
 190 |     |             uint256 result = sqrt(a);
 191 |     |             return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);
 192 |     |         }
 193 |     |     }
 194 |     | 
 195 |     |     /**
 196 |     |      * @dev Return the log in base 2, rounded down, of a positive value.
 197 |     |      * Returns 0 if given 0.
 198 |     |      */
 199 |     |     function log2(uint256 value) internal pure returns (uint256) {
 200 |     |         uint256 result = 0;
 201 |     |         unchecked {
 202 |     |             if (value >> 128 > 0) {
 203 |     |                 value >>= 128;
 204 |     |                 result += 128;
 205 |     |             }
 206 |     |             if (value >> 64 > 0) {
 207 |     |                 value >>= 64;
 208 |     |                 result += 64;
 209 |     |             }
 210 |     |             if (value >> 32 > 0) {
 211 |     |                 value >>= 32;
 212 |     |                 result += 32;
 213 |     |             }
 214 |     |             if (value >> 16 > 0) {
 215 |     |                 value >>= 16;
 216 |     |                 result += 16;
 217 |     |             }
 218 |     |             if (value >> 8 > 0) {
 219 |     |                 value >>= 8;
 220 |     |                 result += 8;
 221 |     |             }
 222 |     |             if (value >> 4 > 0) {
 223 |     |                 value >>= 4;
 224 |     |                 result += 4;
 225 |     |             }
 226 |     |             if (value >> 2 > 0) {
 227 |     |                 value >>= 2;
 228 |     |                 result += 2;
 229 |     |             }
 230 |     |             if (value >> 1 > 0) {
 231 |     |                 result += 1;
 232 |     |             }
 233 |     |         }
 234 |     |         return result;
 235 |     |     }
 236 |     | 
 237 |     |     /**
 238 |     |      * @dev Return the log in base 2, following the selected rounding direction, of a positive value.
 239 |     |      * Returns 0 if given 0.
 240 |     |      */
 241 |     |     function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {
 242 |     |         unchecked {
 243 |     |             uint256 result = log2(value);
 244 |     |             return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);
 245 |     |         }
 246 |     |     }
 247 |     | 
 248 |     |     /**
 249 |     |      * @dev Return the log in base 10, rounded down, of a positive value.
 250 |     |      * Returns 0 if given 0.
 251 |     |      */
 252 |     |     function log10(uint256 value) internal pure returns (uint256) {
 253 |     |         uint256 result = 0;
 254 |     |         unchecked {
 255 |     |             if (value >= 10 ** 64) {
 256 |     |                 value /= 10 ** 64;
 257 |     |                 result += 64;
 258 |     |             }
 259 |     |             if (value >= 10 ** 32) {
 260 |     |                 value /= 10 ** 32;
 261 |     |                 result += 32;
 262 |     |             }
 263 |     |             if (value >= 10 ** 16) {
 264 |     |                 value /= 10 ** 16;
 265 |     |                 result += 16;
 266 |     |             }
 267 |     |             if (value >= 10 ** 8) {
 268 |     |                 value /= 10 ** 8;
 269 |     |                 result += 8;
 270 |     |             }
 271 |     |             if (value >= 10 ** 4) {
 272 |     |                 value /= 10 ** 4;
 273 |     |                 result += 4;
 274 |     |             }
 275 |     |             if (value >= 10 ** 2) {
 276 |     |                 value /= 10 ** 2;
 277 |     |                 result += 2;
 278 |     |             }
 279 |     |             if (value >= 10 ** 1) {
 280 |     |                 result += 1;
 281 |     |             }
 282 |     |         }
 283 |     |         return result;
 284 |     |     }
 285 |     | 
 286 |     |     /**
 287 |     |      * @dev Return the log in base 10, following the selected rounding direction, of a positive value.
 288 |     |      * Returns 0 if given 0.
 289 |     |      */
 290 |     |     function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {
 291 |     |         unchecked {
 292 |     |             uint256 result = log10(value);
 293 |     |             return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);
 294 |     |         }
 295 |     |     }
 296 |     | 
 297 |     |     /**
 298 |     |      * @dev Return the log in base 256, rounded down, of a positive value.
 299 |     |      * Returns 0 if given 0.
 300 |     |      *
 301 |     |      * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.
 302 |     |      */
 303 |     |     function log256(uint256 value) internal pure returns (uint256) {
 304 |     |         uint256 result = 0;
 305 |     |         unchecked {
 306 |     |             if (value >> 128 > 0) {
 307 |     |                 value >>= 128;
 308 |     |                 result += 16;
 309 |     |             }
 310 |     |             if (value >> 64 > 0) {
 311 |     |                 value >>= 64;
 312 |     |                 result += 8;
 313 |     |             }
 314 |     |             if (value >> 32 > 0) {
 315 |     |                 value >>= 32;
 316 |     |                 result += 4;
 317 |     |             }
 318 |     |             if (value >> 16 > 0) {
 319 |     |                 value >>= 16;
 320 |     |                 result += 2;
 321 |     |             }
 322 |     |             if (value >> 8 > 0) {
 323 |     |                 result += 1;
 324 |     |             }
 325 |     |         }
 326 |     |         return result;
 327 |     |     }
 328 |     | 
 329 |     |     /**
 330 |     |      * @dev Return the log in base 256, following the selected rounding direction, of a positive value.
 331 |     |      * Returns 0 if given 0.
 332 |     |      */
 333 |     |     function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {
 334 |     |         unchecked {
 335 |     |             uint256 result = log256(value);
 336 |     |             return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);
 337 |     |         }
 338 |     |     }
 339 |     | }
 340 |     | 

/mnt/c/Users/zerox/repos/bera.buzz-contracts/node_modules/@openzeppelin/contracts/utils/math/SignedMath.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | /**
  7 |     |  * @dev Standard signed math utilities missing in the Solidity language.
  8 |     |  */
  9 |     | library SignedMath {
 10 |     |     /**
 11 |     |      * @dev Returns the largest of two signed numbers.
 12 |     |      */
 13 |     |     function max(int256 a, int256 b) internal pure returns (int256) {
 14 |     |         return a > b ? a : b;
 15 |     |     }
 16 |     | 
 17 |     |     /**
 18 |     |      * @dev Returns the smallest of two signed numbers.
 19 |     |      */
 20 |     |     function min(int256 a, int256 b) internal pure returns (int256) {
 21 |     |         return a < b ? a : b;
 22 |     |     }
 23 |     | 
 24 |     |     /**
 25 |     |      * @dev Returns the average of two signed numbers without overflow.
 26 |     |      * The result is rounded towards zero.
 27 |     |      */
 28 |     |     function average(int256 a, int256 b) internal pure returns (int256) {
 29 |     |         // Formula from the book "Hacker's Delight"
 30 |     |         int256 x = (a & b) + ((a ^ b) >> 1);
 31 |     |         return x + (int256(uint256(x) >> 255) & (a ^ b));
 32 |     |     }
 33 |     | 
 34 |     |     /**
 35 |     |      * @dev Returns the absolute unsigned value of a signed value.
 36 |     |      */
 37 |     |     function abs(int256 n) internal pure returns (uint256) {
 38 |     |         unchecked {
 39 |     |             // must be unchecked in order to support `n = type(int256).min`
 40 |     |             return uint256(n >= 0 ? n : -n);
 41 |     |         }
 42 |     |     }
 43 |     | }
 44 |     | 

/mnt/c/Users/zerox/repos/bera.buzz-contracts/node_modules/solady/src/tokens/ERC20.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity ^0.8.4;
   3 |     | 
   4 |     | /// @notice Simple ERC20 + EIP-2612 implementation.
   5 |     | /// @author Solady (https://github.com/vectorized/solady/blob/main/src/tokens/ERC20.sol)
   6 |     | /// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol)
   7 |     | /// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol)
   8 |     | ///
   9 |     | /// @dev Note:
  10 |     | /// - The ERC20 standard allows minting and transferring to and from the zero address,
  11 |     | ///   minting and transferring zero tokens, as well as self-approvals.
  12 |     | ///   For performance, this implementation WILL NOT revert for such actions.
  13 |     | ///   Please add any checks with overrides if desired.
  14 |     | /// - The `permit` function uses the ecrecover precompile (0x1).
  15 |     | ///
  16 |     | /// If you are overriding:
  17 |     | /// - NEVER violate the ERC20 invariant:
  18 |     | ///   the total sum of all balances must be equal to `totalSupply()`.
  19 |     | /// - Check that the overridden function is actually used in the function you want to
  20 |     | ///   change the behavior of. Much of the code has been manually inlined for performance.
  21 |     | abstract contract ERC20 {
  22 |     |     /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
  23 |     |     /*                       CUSTOM ERRORS                        */
  24 |     |     /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
  25 |     | 
  26 |     |     /// @dev The total supply has overflowed.
  27 |     |     error TotalSupplyOverflow();
  28 |     | 
  29 |     |     /// @dev The allowance has overflowed.
  30 |     |     error AllowanceOverflow();
  31 |     | 
  32 |     |     /// @dev The allowance has underflowed.
  33 |     |     error AllowanceUnderflow();
  34 |     | 
  35 |     |     /// @dev Insufficient balance.
  36 |     |     error InsufficientBalance();
  37 |     | 
  38 |     |     /// @dev Insufficient allowance.
  39 |     |     error InsufficientAllowance();
  40 |     | 
  41 |     |     /// @dev The permit is invalid.
  42 |     |     error InvalidPermit();
  43 |     | 
  44 |     |     /// @dev The permit has expired.
  45 |     |     error PermitExpired();
  46 |     | 
  47 |     |     /// @dev The allowance of Permit2 is fixed at infinity.
  48 |     |     error Permit2AllowanceIsFixedAtInfinity();
  49 |     | 
  50 |     |     /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
  51 |     |     /*                           EVENTS                           */
  52 |     |     /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
  53 |     | 
  54 |     |     /// @dev Emitted when `amount` tokens is transferred from `from` to `to`.
  55 |     |     event Transfer(address indexed from, address indexed to, uint256 amount);
  56 |     | 
  57 |     |     /// @dev Emitted when `amount` tokens is approved by `owner` to be used by `spender`.
  58 |     |     event Approval(address indexed owner, address indexed spender, uint256 amount);
  59 |     | 
  60 |     |     /// @dev `keccak256(bytes("Transfer(address,address,uint256)"))`.
  61 |     |     uint256 private constant _TRANSFER_EVENT_SIGNATURE =
  62 |     |         0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef;
  63 |     | 
  64 |     |     /// @dev `keccak256(bytes("Approval(address,address,uint256)"))`.
  65 |     |     uint256 private constant _APPROVAL_EVENT_SIGNATURE =
  66 |     |         0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925;
  67 |     | 
  68 |     |     /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
  69 |     |     /*                          STORAGE                           */
  70 |     |     /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
  71 |     | 
  72 |     |     /// @dev The storage slot for the total supply.
  73 |     |     uint256 private constant _TOTAL_SUPPLY_SLOT = 0x05345cdf77eb68f44c;
  74 |     | 
  75 |     |     /// @dev The balance slot of `owner` is given by:
  76 |     |     /// ```
  77 |     |     ///     mstore(0x0c, _BALANCE_SLOT_SEED)
  78 |     |     ///     mstore(0x00, owner)
  79 |     |     ///     let balanceSlot := keccak256(0x0c, 0x20)
  80 |     |     /// ```
  81 |     |     uint256 private constant _BALANCE_SLOT_SEED = 0x87a211a2;
  82 |     | 
  83 |     |     /// @dev The allowance slot of (`owner`, `spender`) is given by:
  84 |     |     /// ```
  85 |     |     ///     mstore(0x20, spender)
  86 |     |     ///     mstore(0x0c, _ALLOWANCE_SLOT_SEED)
  87 |     |     ///     mstore(0x00, owner)
  88 |     |     ///     let allowanceSlot := keccak256(0x0c, 0x34)
  89 |     |     /// ```
  90 |     |     uint256 private constant _ALLOWANCE_SLOT_SEED = 0x7f5e9f20;
  91 |     | 
  92 |     |     /// @dev The nonce slot of `owner` is given by:
  93 |     |     /// ```
  94 |     |     ///     mstore(0x0c, _NONCES_SLOT_SEED)
  95 |     |     ///     mstore(0x00, owner)
  96 |     |     ///     let nonceSlot := keccak256(0x0c, 0x20)
  97 |     |     /// ```
  98 |     |     uint256 private constant _NONCES_SLOT_SEED = 0x38377508;
  99 |     | 
 100 |     |     /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
 101 |     |     /*                         CONSTANTS                          */
 102 |     |     /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
 103 |     | 
 104 |     |     /// @dev `(_NONCES_SLOT_SEED << 16) | 0x1901`.
 105 |     |     uint256 private constant _NONCES_SLOT_SEED_WITH_SIGNATURE_PREFIX = 0x383775081901;
 106 |     | 
 107 |     |     /// @dev `keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)")`.
 108 |     |     bytes32 private constant _DOMAIN_TYPEHASH =
 109 |     |         0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f;
 110 |     | 
 111 |     |     /// @dev `keccak256("1")`.
 112 |     |     /// If you need to use a different version, override `_versionHash`.
 113 |     |     bytes32 private constant _DEFAULT_VERSION_HASH =
 114 |     |         0xc89efdaa54c0f20c7adf612882df0950f5a951637e0307cdcb4c672f298b8bc6;
 115 |     | 
 116 |     |     /// @dev `keccak256("Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)")`.
 117 |     |     bytes32 private constant _PERMIT_TYPEHASH =
 118 |     |         0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;
 119 |     | 
 120 |     |     /// @dev The canonical Permit2 address.
 121 |     |     /// For signature-based allowance granting for single transaction ERC20 `transferFrom`.
 122 |     |     /// To enable, override `_givePermit2InfiniteAllowance()`.
 123 |     |     /// [Github](https://github.com/Uniswap/permit2)
 124 |     |     /// [Etherscan](https://etherscan.io/address/0x000000000022D473030F116dDEE9F6B43aC78BA3)
 125 |     |     address internal constant _PERMIT2 = 0x000000000022D473030F116dDEE9F6B43aC78BA3;
 126 |     | 
 127 |     |     /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
 128 |     |     /*                       ERC20 METADATA                       */
 129 |     |     /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
 130 |     | 
 131 |     |     /// @dev Returns the name of the token.
 132 |     |     function name() public view virtual returns (string memory);
 133 |     | 
 134 |     |     /// @dev Returns the symbol of the token.
 135 |     |     function symbol() public view virtual returns (string memory);
 136 |     | 
 137 |     |     /// @dev Returns the decimals places of the token.
 138 |     |     function decimals() public view virtual returns (uint8) {
 139 |     |         return 18;
 140 |     |     }
 141 |     | 
 142 |     |     /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
 143 |     |     /*                           ERC20                            */
 144 |     |     /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
 145 |     | 
 146 |     |     /// @dev Returns the amount of tokens in existence.
 147 |     |     function totalSupply() public view virtual returns (uint256 result) {
 148 |     |         /// @solidity memory-safe-assembly
 149 |     |         assembly {
 150 |     |             result := sload(_TOTAL_SUPPLY_SLOT)
 151 |     |         }
 152 |     |     }
 153 |     | 
 154 |     |     /// @dev Returns the amount of tokens owned by `owner`.
 155 | *   |     function balanceOf(address owner) public view virtual returns (uint256 result) {
 156 |     |         /// @solidity memory-safe-assembly
 157 |     |         assembly {
 158 | *   |             mstore(0x0c, _BALANCE_SLOT_SEED)
 159 | *   |             mstore(0x00, owner)
 160 | *   |             result := sload(keccak256(0x0c, 0x20))
 161 |     |         }
 162 |     |     }
 163 |     | 
 164 |     |     /// @dev Returns the amount of tokens that `spender` can spend on behalf of `owner`.
 165 |     |     function allowance(address owner, address spender)
 166 |     |         public
 167 |     |         view
 168 |     |         virtual
 169 |     |         returns (uint256 result)
 170 |     |     {
 171 |     |         if (_givePermit2InfiniteAllowance()) {
 172 |     |             if (spender == _PERMIT2) return type(uint256).max;
 173 |     |         }
 174 |     |         /// @solidity memory-safe-assembly
 175 |     |         assembly {
 176 |     |             mstore(0x20, spender)
 177 |     |             mstore(0x0c, _ALLOWANCE_SLOT_SEED)
 178 |     |             mstore(0x00, owner)
 179 |     |             result := sload(keccak256(0x0c, 0x34))
 180 |     |         }
 181 |     |     }
 182 |     | 
 183 |     |     /// @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
 184 |     |     ///
 185 |     |     /// Emits a {Approval} event.
 186 | *   |     function approve(address spender, uint256 amount) public virtual returns (bool) {
 187 | *   |         if (_givePermit2InfiniteAllowance()) {
 188 |     |             /// @solidity memory-safe-assembly
 189 |     |             assembly {
 190 |     |                 // If `spender == _PERMIT2 && amount != type(uint256).max`.
 191 |     |                 if iszero(or(xor(shr(96, shl(96, spender)), _PERMIT2), iszero(not(amount)))) {
 192 |     |                     mstore(0x00, 0x3f68539a) // `Permit2AllowanceIsFixedAtInfinity()`.
 193 |     |                     revert(0x1c, 0x04)
 194 |     |                 }
 195 |     |             }
 196 |     |         }
 197 |     |         /// @solidity memory-safe-assembly
 198 |     |         assembly {
 199 |     |             // Compute the allowance slot and store the amount.
 200 | *   |             mstore(0x20, spender)
 201 | *   |             mstore(0x0c, _ALLOWANCE_SLOT_SEED)
 202 | *   |             mstore(0x00, caller())
 203 | *   |             sstore(keccak256(0x0c, 0x34), amount)
 204 |     |             // Emit the {Approval} event.
 205 | *   |             mstore(0x00, amount)
 206 | *   |             log3(0x00, 0x20, _APPROVAL_EVENT_SIGNATURE, caller(), shr(96, mload(0x2c)))
 207 |     |         }
 208 | *   |         return true;
 209 |     |     }
 210 |     | 
 211 |     |     /// @dev Transfer `amount` tokens from the caller to `to`.
 212 |     |     ///
 213 |     |     /// Requirements:
 214 |     |     /// - `from` must at least have `amount`.
 215 |     |     ///
 216 |     |     /// Emits a {Transfer} event.
 217 |     |     function transfer(address to, uint256 amount) public virtual returns (bool) {
 218 |     |         _beforeTokenTransfer(msg.sender, to, amount);
 219 |     |         /// @solidity memory-safe-assembly
 220 |     |         assembly {
 221 |     |             // Compute the balance slot and load its value.
 222 |     |             mstore(0x0c, _BALANCE_SLOT_SEED)
 223 |     |             mstore(0x00, caller())
 224 |     |             let fromBalanceSlot := keccak256(0x0c, 0x20)
 225 |     |             let fromBalance := sload(fromBalanceSlot)
 226 |     |             // Revert if insufficient balance.
 227 |     |             if gt(amount, fromBalance) {
 228 |     |                 mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.
 229 |     |                 revert(0x1c, 0x04)
 230 |     |             }
 231 |     |             // Subtract and store the updated balance.
 232 |     |             sstore(fromBalanceSlot, sub(fromBalance, amount))
 233 |     |             // Compute the balance slot of `to`.
 234 |     |             mstore(0x00, to)
 235 |     |             let toBalanceSlot := keccak256(0x0c, 0x20)
 236 |     |             // Add and store the updated balance of `to`.
 237 |     |             // Will not overflow because the sum of all user balances
 238 |     |             // cannot exceed the maximum uint256 value.
 239 |     |             sstore(toBalanceSlot, add(sload(toBalanceSlot), amount))
 240 |     |             // Emit the {Transfer} event.
 241 |     |             mstore(0x20, amount)
 242 |     |             log3(0x20, 0x20, _TRANSFER_EVENT_SIGNATURE, caller(), shr(96, mload(0x0c)))
 243 |     |         }
 244 |     |         _afterTokenTransfer(msg.sender, to, amount);
 245 |     |         return true;
 246 |     |     }
 247 |     | 
 248 |     |     /// @dev Transfers `amount` tokens from `from` to `to`.
 249 |     |     ///
 250 |     |     /// Note: Does not update the allowance if it is the maximum uint256 value.
 251 |     |     ///
 252 |     |     /// Requirements:
 253 |     |     /// - `from` must at least have `amount`.
 254 |     |     /// - The caller must have at least `amount` of allowance to transfer the tokens of `from`.
 255 |     |     ///
 256 |     |     /// Emits a {Transfer} event.
 257 |     |     function transferFrom(address from, address to, uint256 amount) public virtual returns (bool) {
 258 |     |         _beforeTokenTransfer(from, to, amount);
 259 |     |         // Code duplication is for zero-cost abstraction if possible.
 260 |     |         if (_givePermit2InfiniteAllowance()) {
 261 |     |             /// @solidity memory-safe-assembly
 262 |     |             assembly {
 263 |     |                 let from_ := shl(96, from)
 264 |     |                 if iszero(eq(caller(), _PERMIT2)) {
 265 |     |                     // Compute the allowance slot and load its value.
 266 |     |                     mstore(0x20, caller())
 267 |     |                     mstore(0x0c, or(from_, _ALLOWANCE_SLOT_SEED))
 268 |     |                     let allowanceSlot := keccak256(0x0c, 0x34)
 269 |     |                     let allowance_ := sload(allowanceSlot)
 270 |     |                     // If the allowance is not the maximum uint256 value.
 271 |     |                     if not(allowance_) {
 272 |     |                         // Revert if the amount to be transferred exceeds the allowance.
 273 |     |                         if gt(amount, allowance_) {
 274 |     |                             mstore(0x00, 0x13be252b) // `InsufficientAllowance()`.
 275 |     |                             revert(0x1c, 0x04)
 276 |     |                         }
 277 |     |                         // Subtract and store the updated allowance.
 278 |     |                         sstore(allowanceSlot, sub(allowance_, amount))
 279 |     |                     }
 280 |     |                 }
 281 |     |                 // Compute the balance slot and load its value.
 282 |     |                 mstore(0x0c, or(from_, _BALANCE_SLOT_SEED))
 283 |     |                 let fromBalanceSlot := keccak256(0x0c, 0x20)
 284 |     |                 let fromBalance := sload(fromBalanceSlot)
 285 |     |                 // Revert if insufficient balance.
 286 |     |                 if gt(amount, fromBalance) {
 287 |     |                     mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.
 288 |     |                     revert(0x1c, 0x04)
 289 |     |                 }
 290 |     |                 // Subtract and store the updated balance.
 291 |     |                 sstore(fromBalanceSlot, sub(fromBalance, amount))
 292 |     |                 // Compute the balance slot of `to`.
 293 |     |                 mstore(0x00, to)
 294 |     |                 let toBalanceSlot := keccak256(0x0c, 0x20)
 295 |     |                 // Add and store the updated balance of `to`.
 296 |     |                 // Will not overflow because the sum of all user balances
 297 |     |                 // cannot exceed the maximum uint256 value.
 298 |     |                 sstore(toBalanceSlot, add(sload(toBalanceSlot), amount))
 299 |     |                 // Emit the {Transfer} event.
 300 |     |                 mstore(0x20, amount)
 301 |     |                 log3(0x20, 0x20, _TRANSFER_EVENT_SIGNATURE, shr(96, from_), shr(96, mload(0x0c)))
 302 |     |             }
 303 |     |         } else {
 304 |     |             /// @solidity memory-safe-assembly
 305 |     |             assembly {
 306 |     |                 let from_ := shl(96, from)
 307 |     |                 // Compute the allowance slot and load its value.
 308 |     |                 mstore(0x20, caller())
 309 |     |                 mstore(0x0c, or(from_, _ALLOWANCE_SLOT_SEED))
 310 |     |                 let allowanceSlot := keccak256(0x0c, 0x34)
 311 |     |                 let allowance_ := sload(allowanceSlot)
 312 |     |                 // If the allowance is not the maximum uint256 value.
 313 |     |                 if not(allowance_) {
 314 |     |                     // Revert if the amount to be transferred exceeds the allowance.
 315 |     |                     if gt(amount, allowance_) {
 316 |     |                         mstore(0x00, 0x13be252b) // `InsufficientAllowance()`.
 317 |     |                         revert(0x1c, 0x04)
 318 |     |                     }
 319 |     |                     // Subtract and store the updated allowance.
 320 |     |                     sstore(allowanceSlot, sub(allowance_, amount))
 321 |     |                 }
 322 |     |                 // Compute the balance slot and load its value.
 323 |     |                 mstore(0x0c, or(from_, _BALANCE_SLOT_SEED))
 324 |     |                 let fromBalanceSlot := keccak256(0x0c, 0x20)
 325 |     |                 let fromBalance := sload(fromBalanceSlot)
 326 |     |                 // Revert if insufficient balance.
 327 |     |                 if gt(amount, fromBalance) {
 328 |     |                     mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.
 329 |     |                     revert(0x1c, 0x04)
 330 |     |                 }
 331 |     |                 // Subtract and store the updated balance.
 332 |     |                 sstore(fromBalanceSlot, sub(fromBalance, amount))
 333 |     |                 // Compute the balance slot of `to`.
 334 |     |                 mstore(0x00, to)
 335 |     |                 let toBalanceSlot := keccak256(0x0c, 0x20)
 336 |     |                 // Add and store the updated balance of `to`.
 337 |     |                 // Will not overflow because the sum of all user balances
 338 |     |                 // cannot exceed the maximum uint256 value.
 339 |     |                 sstore(toBalanceSlot, add(sload(toBalanceSlot), amount))
 340 |     |                 // Emit the {Transfer} event.
 341 |     |                 mstore(0x20, amount)
 342 |     |                 log3(0x20, 0x20, _TRANSFER_EVENT_SIGNATURE, shr(96, from_), shr(96, mload(0x0c)))
 343 |     |             }
 344 |     |         }
 345 |     |         _afterTokenTransfer(from, to, amount);
 346 |     |         return true;
 347 |     |     }
 348 |     | 
 349 |     |     /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
 350 |     |     /*                          EIP-2612                          */
 351 |     |     /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
 352 |     | 
 353 |     |     /// @dev For more performance, override to return the constant value
 354 |     |     /// of `keccak256(bytes(name()))` if `name()` will never change.
 355 |     |     function _constantNameHash() internal view virtual returns (bytes32 result) {}
 356 |     | 
 357 |     |     /// @dev If you need a different value, override this function.
 358 |     |     function _versionHash() internal view virtual returns (bytes32 result) {
 359 |     |         result = _DEFAULT_VERSION_HASH;
 360 |     |     }
 361 |     | 
 362 |     |     /// @dev Returns the current nonce for `owner`.
 363 |     |     /// This value is used to compute the signature for EIP-2612 permit.
 364 |     |     function nonces(address owner) public view virtual returns (uint256 result) {
 365 |     |         /// @solidity memory-safe-assembly
 366 |     |         assembly {
 367 |     |             // Compute the nonce slot and load its value.
 368 |     |             mstore(0x0c, _NONCES_SLOT_SEED)
 369 |     |             mstore(0x00, owner)
 370 |     |             result := sload(keccak256(0x0c, 0x20))
 371 |     |         }
 372 |     |     }
 373 |     | 
 374 |     |     /// @dev Sets `value` as the allowance of `spender` over the tokens of `owner`,
 375 |     |     /// authorized by a signed approval by `owner`.
 376 |     |     ///
 377 |     |     /// Emits a {Approval} event.
 378 |     |     function permit(
 379 |     |         address owner,
 380 |     |         address spender,
 381 |     |         uint256 value,
 382 |     |         uint256 deadline,
 383 |     |         uint8 v,
 384 |     |         bytes32 r,
 385 |     |         bytes32 s
 386 |     |     ) public virtual {
 387 |     |         if (_givePermit2InfiniteAllowance()) {
 388 |     |             /// @solidity memory-safe-assembly
 389 |     |             assembly {
 390 |     |                 // If `spender == _PERMIT2 && value != type(uint256).max`.
 391 |     |                 if iszero(or(xor(shr(96, shl(96, spender)), _PERMIT2), iszero(not(value)))) {
 392 |     |                     mstore(0x00, 0x3f68539a) // `Permit2AllowanceIsFixedAtInfinity()`.
 393 |     |                     revert(0x1c, 0x04)
 394 |     |                 }
 395 |     |             }
 396 |     |         }
 397 |     |         bytes32 nameHash = _constantNameHash();
 398 |     |         //  We simply calculate it on-the-fly to allow for cases where the `name` may change.
 399 |     |         if (nameHash == bytes32(0)) nameHash = keccak256(bytes(name()));
 400 |     |         bytes32 versionHash = _versionHash();
 401 |     |         /// @solidity memory-safe-assembly
 402 |     |         assembly {
 403 |     |             // Revert if the block timestamp is greater than `deadline`.
 404 |     |             if gt(timestamp(), deadline) {
 405 |     |                 mstore(0x00, 0x1a15a3cc) // `PermitExpired()`.
 406 |     |                 revert(0x1c, 0x04)
 407 |     |             }
 408 |     |             let m := mload(0x40) // Grab the free memory pointer.
 409 |     |             // Clean the upper 96 bits.
 410 |     |             owner := shr(96, shl(96, owner))
 411 |     |             spender := shr(96, shl(96, spender))
 412 |     |             // Compute the nonce slot and load its value.
 413 |     |             mstore(0x0e, _NONCES_SLOT_SEED_WITH_SIGNATURE_PREFIX)
 414 |     |             mstore(0x00, owner)
 415 |     |             let nonceSlot := keccak256(0x0c, 0x20)
 416 |     |             let nonceValue := sload(nonceSlot)
 417 |     |             // Prepare the domain separator.
 418 |     |             mstore(m, _DOMAIN_TYPEHASH)
 419 |     |             mstore(add(m, 0x20), nameHash)
 420 |     |             mstore(add(m, 0x40), versionHash)
 421 |     |             mstore(add(m, 0x60), chainid())
 422 |     |             mstore(add(m, 0x80), address())
 423 |     |             mstore(0x2e, keccak256(m, 0xa0))
 424 |     |             // Prepare the struct hash.
 425 |     |             mstore(m, _PERMIT_TYPEHASH)
 426 |     |             mstore(add(m, 0x20), owner)
 427 |     |             mstore(add(m, 0x40), spender)
 428 |     |             mstore(add(m, 0x60), value)
 429 |     |             mstore(add(m, 0x80), nonceValue)
 430 |     |             mstore(add(m, 0xa0), deadline)
 431 |     |             mstore(0x4e, keccak256(m, 0xc0))
 432 |     |             // Prepare the ecrecover calldata.
 433 |     |             mstore(0x00, keccak256(0x2c, 0x42))
 434 |     |             mstore(0x20, and(0xff, v))
 435 |     |             mstore(0x40, r)
 436 |     |             mstore(0x60, s)
 437 |     |             let t := staticcall(gas(), 1, 0, 0x80, 0x20, 0x20)
 438 |     |             // If the ecrecover fails, the returndatasize will be 0x00,
 439 |     |             // `owner` will be checked if it equals the hash at 0x00,
 440 |     |             // which evaluates to false (i.e. 0), and we will revert.
 441 |     |             // If the ecrecover succeeds, the returndatasize will be 0x20,
 442 |     |             // `owner` will be compared against the returned address at 0x20.
 443 |     |             if iszero(eq(mload(returndatasize()), owner)) {
 444 |     |                 mstore(0x00, 0xddafbaef) // `InvalidPermit()`.
 445 |     |                 revert(0x1c, 0x04)
 446 |     |             }
 447 |     |             // Increment and store the updated nonce.
 448 |     |             sstore(nonceSlot, add(nonceValue, t)) // `t` is 1 if ecrecover succeeds.
 449 |     |             // Compute the allowance slot and store the value.
 450 |     |             // The `owner` is already at slot 0x20.
 451 |     |             mstore(0x40, or(shl(160, _ALLOWANCE_SLOT_SEED), spender))
 452 |     |             sstore(keccak256(0x2c, 0x34), value)
 453 |     |             // Emit the {Approval} event.
 454 |     |             log3(add(m, 0x60), 0x20, _APPROVAL_EVENT_SIGNATURE, owner, spender)
 455 |     |             mstore(0x40, m) // Restore the free memory pointer.
 456 |     |             mstore(0x60, 0) // Restore the zero pointer.
 457 |     |         }
 458 |     |     }
 459 |     | 
 460 |     |     /// @dev Returns the EIP-712 domain separator for the EIP-2612 permit.
 461 |     |     function DOMAIN_SEPARATOR() public view virtual returns (bytes32 result) {
 462 |     |         bytes32 nameHash = _constantNameHash();
 463 |     |         //  We simply calculate it on-the-fly to allow for cases where the `name` may change.
 464 |     |         if (nameHash == bytes32(0)) nameHash = keccak256(bytes(name()));
 465 |     |         bytes32 versionHash = _versionHash();
 466 |     |         /// @solidity memory-safe-assembly
 467 |     |         assembly {
 468 |     |             let m := mload(0x40) // Grab the free memory pointer.
 469 |     |             mstore(m, _DOMAIN_TYPEHASH)
 470 |     |             mstore(add(m, 0x20), nameHash)
 471 |     |             mstore(add(m, 0x40), versionHash)
 472 |     |             mstore(add(m, 0x60), chainid())
 473 |     |             mstore(add(m, 0x80), address())
 474 |     |             result := keccak256(m, 0xa0)
 475 |     |         }
 476 |     |     }
 477 |     | 
 478 |     |     /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
 479 |     |     /*                  INTERNAL MINT FUNCTIONS                   */
 480 |     |     /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
 481 |     | 
 482 |     |     /// @dev Mints `amount` tokens to `to`, increasing the total supply.
 483 |     |     ///
 484 |     |     /// Emits a {Transfer} event.
 485 | *   |     function _mint(address to, uint256 amount) internal virtual {
 486 | *   |         _beforeTokenTransfer(address(0), to, amount);
 487 |     |         /// @solidity memory-safe-assembly
 488 | *   |         assembly {
 489 | *   |             let totalSupplyBefore := sload(_TOTAL_SUPPLY_SLOT)
 490 | *   |             let totalSupplyAfter := add(totalSupplyBefore, amount)
 491 |     |             // Revert if the total supply overflows.
 492 | *   |             if lt(totalSupplyAfter, totalSupplyBefore) {
 493 |     |                 mstore(0x00, 0xe5cfe957) // `TotalSupplyOverflow()`.
 494 |     |                 revert(0x1c, 0x04)
 495 |     |             }
 496 |     |             // Store the updated total supply.
 497 | *   |             sstore(_TOTAL_SUPPLY_SLOT, totalSupplyAfter)
 498 |     |             // Compute the balance slot and load its value.
 499 | *   |             mstore(0x0c, _BALANCE_SLOT_SEED)
 500 | *   |             mstore(0x00, to)
 501 | *   |             let toBalanceSlot := keccak256(0x0c, 0x20)
 502 |     |             // Add and store the updated balance.
 503 | *   |             sstore(toBalanceSlot, add(sload(toBalanceSlot), amount))
 504 |     |             // Emit the {Transfer} event.
 505 | *   |             mstore(0x20, amount)
 506 | *   |             log3(0x20, 0x20, _TRANSFER_EVENT_SIGNATURE, 0, shr(96, mload(0x0c)))
 507 |     |         }
 508 | *   |         _afterTokenTransfer(address(0), to, amount);
 509 |     |     }
 510 |     | 
 511 |     |     /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
 512 |     |     /*                  INTERNAL BURN FUNCTIONS                   */
 513 |     |     /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
 514 |     | 
 515 |     |     /// @dev Burns `amount` tokens from `from`, reducing the total supply.
 516 |     |     ///
 517 |     |     /// Emits a {Transfer} event.
 518 |     |     function _burn(address from, uint256 amount) internal virtual {
 519 |     |         _beforeTokenTransfer(from, address(0), amount);
 520 |     |         /// @solidity memory-safe-assembly
 521 |     |         assembly {
 522 |     |             // Compute the balance slot and load its value.
 523 |     |             mstore(0x0c, _BALANCE_SLOT_SEED)
 524 |     |             mstore(0x00, from)
 525 |     |             let fromBalanceSlot := keccak256(0x0c, 0x20)
 526 |     |             let fromBalance := sload(fromBalanceSlot)
 527 |     |             // Revert if insufficient balance.
 528 |     |             if gt(amount, fromBalance) {
 529 |     |                 mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.
 530 |     |                 revert(0x1c, 0x04)
 531 |     |             }
 532 |     |             // Subtract and store the updated balance.
 533 |     |             sstore(fromBalanceSlot, sub(fromBalance, amount))
 534 |     |             // Subtract and store the updated total supply.
 535 |     |             sstore(_TOTAL_SUPPLY_SLOT, sub(sload(_TOTAL_SUPPLY_SLOT), amount))
 536 |     |             // Emit the {Transfer} event.
 537 |     |             mstore(0x00, amount)
 538 |     |             log3(0x00, 0x20, _TRANSFER_EVENT_SIGNATURE, shr(96, shl(96, from)), 0)
 539 |     |         }
 540 |     |         _afterTokenTransfer(from, address(0), amount);
 541 |     |     }
 542 |     | 
 543 |     |     /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
 544 |     |     /*                INTERNAL TRANSFER FUNCTIONS                 */
 545 |     |     /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
 546 |     | 
 547 |     |     /// @dev Moves `amount` of tokens from `from` to `to`.
 548 |     |     function _transfer(address from, address to, uint256 amount) internal virtual {
 549 |     |         _beforeTokenTransfer(from, to, amount);
 550 |     |         /// @solidity memory-safe-assembly
 551 |     |         assembly {
 552 |     |             let from_ := shl(96, from)
 553 |     |             // Compute the balance slot and load its value.
 554 |     |             mstore(0x0c, or(from_, _BALANCE_SLOT_SEED))
 555 |     |             let fromBalanceSlot := keccak256(0x0c, 0x20)
 556 |     |             let fromBalance := sload(fromBalanceSlot)
 557 |     |             // Revert if insufficient balance.
 558 |     |             if gt(amount, fromBalance) {
 559 |     |                 mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.
 560 |     |                 revert(0x1c, 0x04)
 561 |     |             }
 562 |     |             // Subtract and store the updated balance.
 563 |     |             sstore(fromBalanceSlot, sub(fromBalance, amount))
 564 |     |             // Compute the balance slot of `to`.
 565 |     |             mstore(0x00, to)
 566 |     |             let toBalanceSlot := keccak256(0x0c, 0x20)
 567 |     |             // Add and store the updated balance of `to`.
 568 |     |             // Will not overflow because the sum of all user balances
 569 |     |             // cannot exceed the maximum uint256 value.
 570 |     |             sstore(toBalanceSlot, add(sload(toBalanceSlot), amount))
 571 |     |             // Emit the {Transfer} event.
 572 |     |             mstore(0x20, amount)
 573 |     |             log3(0x20, 0x20, _TRANSFER_EVENT_SIGNATURE, shr(96, from_), shr(96, mload(0x0c)))
 574 |     |         }
 575 |     |         _afterTokenTransfer(from, to, amount);
 576 |     |     }
 577 |     | 
 578 |     |     /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
 579 |     |     /*                INTERNAL ALLOWANCE FUNCTIONS                */
 580 |     |     /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
 581 |     | 
 582 |     |     /// @dev Updates the allowance of `owner` for `spender` based on spent `amount`.
 583 |     |     function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {
 584 |     |         if (_givePermit2InfiniteAllowance()) {
 585 |     |             if (spender == _PERMIT2) return; // Do nothing, as allowance is infinite.
 586 |     |         }
 587 |     |         /// @solidity memory-safe-assembly
 588 |     |         assembly {
 589 |     |             // Compute the allowance slot and load its value.
 590 |     |             mstore(0x20, spender)
 591 |     |             mstore(0x0c, _ALLOWANCE_SLOT_SEED)
 592 |     |             mstore(0x00, owner)
 593 |     |             let allowanceSlot := keccak256(0x0c, 0x34)
 594 |     |             let allowance_ := sload(allowanceSlot)
 595 |     |             // If the allowance is not the maximum uint256 value.
 596 |     |             if not(allowance_) {
 597 |     |                 // Revert if the amount to be transferred exceeds the allowance.
 598 |     |                 if gt(amount, allowance_) {
 599 |     |                     mstore(0x00, 0x13be252b) // `InsufficientAllowance()`.
 600 |     |                     revert(0x1c, 0x04)
 601 |     |                 }
 602 |     |                 // Subtract and store the updated allowance.
 603 |     |                 sstore(allowanceSlot, sub(allowance_, amount))
 604 |     |             }
 605 |     |         }
 606 |     |     }
 607 |     | 
 608 |     |     /// @dev Sets `amount` as the allowance of `spender` over the tokens of `owner`.
 609 |     |     ///
 610 |     |     /// Emits a {Approval} event.
 611 |     |     function _approve(address owner, address spender, uint256 amount) internal virtual {
 612 |     |         if (_givePermit2InfiniteAllowance()) {
 613 |     |             /// @solidity memory-safe-assembly
 614 |     |             assembly {
 615 |     |                 // If `spender == _PERMIT2 && amount != type(uint256).max`.
 616 |     |                 if iszero(or(xor(shr(96, shl(96, spender)), _PERMIT2), iszero(not(amount)))) {
 617 |     |                     mstore(0x00, 0x3f68539a) // `Permit2AllowanceIsFixedAtInfinity()`.
 618 |     |                     revert(0x1c, 0x04)
 619 |     |                 }
 620 |     |             }
 621 |     |         }
 622 |     |         /// @solidity memory-safe-assembly
 623 |     |         assembly {
 624 |     |             let owner_ := shl(96, owner)
 625 |     |             // Compute the allowance slot and store the amount.
 626 |     |             mstore(0x20, spender)
 627 |     |             mstore(0x0c, or(owner_, _ALLOWANCE_SLOT_SEED))
 628 |     |             sstore(keccak256(0x0c, 0x34), amount)
 629 |     |             // Emit the {Approval} event.
 630 |     |             mstore(0x00, amount)
 631 |     |             log3(0x00, 0x20, _APPROVAL_EVENT_SIGNATURE, shr(96, owner_), shr(96, mload(0x2c)))
 632 |     |         }
 633 |     |     }
 634 |     | 
 635 |     |     /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
 636 |     |     /*                     HOOKS TO OVERRIDE                      */
 637 |     |     /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
 638 |     | 
 639 |     |     /// @dev Hook that is called before any transfer of tokens.
 640 |     |     /// This includes minting and burning.
 641 | *   |     function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}
 642 |     | 
 643 |     |     /// @dev Hook that is called after any transfer of tokens.
 644 |     |     /// This includes minting and burning.
 645 | *   |     function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}
 646 |     | 
 647 |     |     /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
 648 |     |     /*                          PERMIT2                           */
 649 |     |     /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
 650 |     | 
 651 |     |     /// @dev Returns whether to fix the Permit2 contract's allowance at infinity.
 652 |     |     ///
 653 |     |     /// This value should be kept constant after contract initialization,
 654 |     |     /// or else the actual allowance values may not match with the {Approval} events.
 655 |     |     /// For best performance, return a compile-time constant for zero-cost abstraction.
 656 | *   |     function _givePermit2InfiniteAllowance() internal view virtual returns (bool) {
 657 |     |         return false;
 658 |     |     }
 659 |     | }
 660 |     | 

/mnt/c/Users/zerox/repos/bera.buzz-contracts/node_modules/solady/src/tokens/WETH.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.4;
  3 |     | 
  4 |     | import {ERC20} from "./ERC20.sol";
  5 |     | 
  6 |     | /// @notice Simple Wrapped Ether implementation.
  7 |     | /// @author Solady (https://github.com/vectorized/solady/blob/main/src/tokens/WETH.sol)
  8 |     | /// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/WETH.sol)
  9 |     | /// @author Inspired by WETH9 (https://github.com/dapphub/ds-weth/blob/master/src/weth9.sol)
 10 |     | contract WETH is ERC20 {
 11 |     |     /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
 12 |     |     /*                       CUSTOM ERRORS                        */
 13 |     |     /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
 14 |     | 
 15 |     |     /// @dev The ETH transfer has failed.
 16 |     |     error ETHTransferFailed();
 17 |     | 
 18 |     |     /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
 19 |     |     /*                       ERC20 METADATA                       */
 20 |     |     /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
 21 |     | 
 22 |     |     /// @dev Returns the name of the token.
 23 |     |     function name() public view virtual override returns (string memory) {
 24 |     |         return "Wrapped Ether";
 25 |     |     }
 26 |     | 
 27 |     |     /// @dev Returns the symbol of the token.
 28 |     |     function symbol() public view virtual override returns (string memory) {
 29 |     |         return "WETH";
 30 |     |     }
 31 |     | 
 32 |     |     /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
 33 |     |     /*                            WETH                            */
 34 |     |     /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
 35 |     | 
 36 |     |     /// @dev Deposits `amount` ETH of the caller and mints `amount` WETH to the caller.
 37 | *   |     function deposit() public payable virtual {
 38 | *   |         _mint(msg.sender, msg.value);
 39 |     |     }
 40 |     | 
 41 |     |     /// @dev Burns `amount` WETH of the caller and sends `amount` ETH to the caller.
 42 |     |     function withdraw(uint256 amount) public virtual {
 43 |     |         _burn(msg.sender, amount);
 44 |     |         /// @solidity memory-safe-assembly
 45 |     |         assembly {
 46 |     |             // Transfer the ETH and check if it succeeded or not.
 47 |     |             if iszero(call(gas(), caller(), amount, codesize(), 0x00, codesize(), 0x00)) {
 48 |     |                 mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.
 49 |     |                 revert(0x1c, 0x04)
 50 |     |             }
 51 |     |         }
 52 |     |     }
 53 |     | 
 54 |     |     /// @dev Equivalent to `deposit()`.
 55 |     |     receive() external payable virtual {
 56 |     |         deposit();
 57 |     |     }
 58 |     | }
 59 |     | 

/mnt/c/Users/zerox/repos/bera.buzz-contracts/node_modules/solmate/src/utils/Bytes32AddressLib.sol
  1 |     | // SPDX-License-Identifier: AGPL-3.0-only
  2 |     | pragma solidity >=0.8.0;
  3 |     | 
  4 |     | /// @notice Library for converting between addresses and bytes32 values.
  5 |     | /// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/Bytes32AddressLib.sol)
  6 |     | library Bytes32AddressLib {
  7 | *   |     function fromLast20Bytes(bytes32 bytesValue) internal pure returns (address) {
  8 | *   |         return address(uint160(uint256(bytesValue)));
  9 |     |     }
 10 |     | 
 11 |     |     function fillLast12Bytes(address addressValue) internal pure returns (bytes32) {
 12 |     |         return bytes32(bytes20(addressValue));
 13 |     |     }
 14 |     | }
 15 |     | 

/mnt/c/Users/zerox/repos/bera.buzz-contracts/node_modules/solmate/src/utils/CREATE3.sol
  1 |     | // SPDX-License-Identifier: AGPL-3.0-only
  2 |     | pragma solidity >=0.8.0;
  3 |     | 
  4 |     | import {Bytes32AddressLib} from "./Bytes32AddressLib.sol";
  5 |     | 
  6 |     | /// @notice Deploy to deterministic addresses without an initcode factor.
  7 |     | /// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/CREATE3.sol)
  8 |     | /// @author Modified from 0xSequence (https://github.com/0xSequence/create3/blob/master/contracts/Create3.sol)
  9 |     | library CREATE3 {
 10 |     |     using Bytes32AddressLib for bytes32;
 11 |     | 
 12 |     |     //--------------------------------------------------------------------------------//
 13 |     |     // Opcode     | Opcode + Arguments    | Description      | Stack View             //
 14 |     |     //--------------------------------------------------------------------------------//
 15 |     |     // 0x36       |  0x36                 | CALLDATASIZE     | size                   //
 16 |     |     // 0x3d       |  0x3d                 | RETURNDATASIZE   | 0 size                 //
 17 |     |     // 0x3d       |  0x3d                 | RETURNDATASIZE   | 0 0 size               //
 18 |     |     // 0x37       |  0x37                 | CALLDATACOPY     |                        //
 19 |     |     // 0x36       |  0x36                 | CALLDATASIZE     | size                   //
 20 |     |     // 0x3d       |  0x3d                 | RETURNDATASIZE   | 0 size                 //
 21 |     |     // 0x34       |  0x34                 | CALLVALUE        | value 0 size           //
 22 |     |     // 0xf0       |  0xf0                 | CREATE           | newContract            //
 23 |     |     //--------------------------------------------------------------------------------//
 24 |     |     // Opcode     | Opcode + Arguments    | Description      | Stack View             //
 25 |     |     //--------------------------------------------------------------------------------//
 26 |     |     // 0x67       |  0x67XXXXXXXXXXXXXXXX | PUSH8 bytecode   | bytecode               //
 27 |     |     // 0x3d       |  0x3d                 | RETURNDATASIZE   | 0 bytecode             //
 28 |     |     // 0x52       |  0x52                 | MSTORE           |                        //
 29 |     |     // 0x60       |  0x6008               | PUSH1 08         | 8                      //
 30 |     |     // 0x60       |  0x6018               | PUSH1 18         | 24 8                   //
 31 |     |     // 0xf3       |  0xf3                 | RETURN           |                        //
 32 |     |     //--------------------------------------------------------------------------------//
 33 |     |     bytes internal constant PROXY_BYTECODE = hex"67_36_3d_3d_37_36_3d_34_f0_3d_52_60_08_60_18_f3";
 34 |     | 
 35 | *   |     bytes32 internal constant PROXY_BYTECODE_HASH = keccak256(PROXY_BYTECODE);
 36 |     | 
 37 | *   |     function deploy(
 38 |     |         bytes32 salt,
 39 |     |         bytes memory creationCode,
 40 |     |         uint256 value
 41 | *   |     ) internal returns (address deployed) {
 42 | *   |         bytes memory proxyChildBytecode = PROXY_BYTECODE;
 43 |     | 
 44 | *   |         address proxy;
 45 |     |         /// @solidity memory-safe-assembly
 46 |     |         assembly {
 47 |     |             // Deploy a new contract with our pre-made bytecode via CREATE2.
 48 |     |             // We start 32 bytes into the code to avoid copying the byte length.
 49 | *   |             proxy := create2(0, add(proxyChildBytecode, 32), mload(proxyChildBytecode), salt)
 50 |     |         }
 51 | *   |         require(proxy != address(0), "DEPLOYMENT_FAILED");
 52 |     | 
 53 | *   |         deployed = getDeployed(salt);
 54 | *   |         (bool success, ) = proxy.call{value: value}(creationCode);
 55 | *   |         require(success && deployed.code.length != 0, "INITIALIZATION_FAILED");
 56 |     |     }
 57 |     | 
 58 | *   |     function getDeployed(bytes32 salt) internal view returns (address) {
 59 | *   |         return getDeployed(salt, address(this));
 60 |     |     }
 61 |     | 
 62 | *   |     function getDeployed(bytes32 salt, address creator) internal pure returns (address) {
 63 | *   |         address proxy = keccak256(
 64 | *   |             abi.encodePacked(
 65 |     |                 // Prefix:
 66 | *   |                 bytes1(0xFF),
 67 |     |                 // Creator:
 68 | *   |                 creator,
 69 |     |                 // Salt:
 70 | *   |                 salt,
 71 |     |                 // Bytecode hash:
 72 |     |                 PROXY_BYTECODE_HASH
 73 |     |             )
 74 |     |         ).fromLast20Bytes();
 75 |     | 
 76 | *   |         return
 77 | *   |             keccak256(
 78 | *   |                 abi.encodePacked(
 79 |     |                     // 0xd6 = 0xc0 (short RLP prefix) + 0x16 (length of: 0x94 ++ proxy ++ 0x01)
 80 |     |                     // 0x94 = 0x80 + 0x14 (0x14 = the length of an address, 20 bytes, in hex)
 81 |     |                     hex"d6_94",
 82 | *   |                     proxy,
 83 |     |                     hex"01" // Nonce of the proxy contract (1)
 84 |     |                 )
 85 |     |             ).fromLast20Bytes();
 86 |     |     }
 87 |     | }
 88 |     | 

/mnt/c/Users/zerox/repos/bera.buzz-contracts/test/invariant/Base.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity ^0.8.19;
   3 |     | 
   4 |     | import {PropertiesAsserts} from "@crytic/properties/contracts/util/PropertiesHelper.sol";
   5 |     | import {hevm} from "@crytic/properties/contracts/util/Hevm.sol";
   6 |     | import {User} from "./utils/User.sol";
   7 |     | 
   8 |     | import {BuzzTokenFactory} from "../../contracts/BuzzTokenFactory.sol";
   9 |     | import {BuzzVault} from "../../contracts/BuzzVault.sol";
  10 |     | import {BuzzVaultExponential} from "../../contracts/BuzzVaultExponential.sol";
  11 |     | import {FeeManager} from "../../contracts/FeeManager.sol";
  12 |     | import {HighlightsManager} from "../../contracts/HighlightsManager.sol";
  13 |     | import {ReferralManager} from "../../contracts/ReferralManager.sol";
  14 |     | import {BexLiquidityManagerMock} from "./mocks/BexLiquidityManagerMock.sol";
  15 |     | import {ERC20Mock} from "./mocks/ERC20Mock.sol";
  16 |     | import {WBERA} from "../../contracts/mock/WBERA.sol";
  17 |     | import {CREATE3FactoryMock} from "../../contracts/mock/create/CREATE3FactoryMock.sol";
  18 |     | 
  19 |     | contract Base is PropertiesAsserts {
  20 | *   |     uint256 internal constant NUMBER_OF_USERS = 10;
  21 | *   |     uint256 internal constant NUMBER_OF_BASE_TOKENS = 3;
  22 |     | 
  23 | *   |     uint256 internal constant TRADING_FEE_BPS = 100;
  24 | *   |     uint256 internal constant LISTING_FEE = 2e15;
  25 | *   |     uint256 internal constant MIGRATION_FEE_BPS = 420;
  26 | *   |     uint256 internal constant DIRECT_REF_FEE_BPS = 1500;
  27 | *   |     uint256 internal constant INDIRECT_REF_FEE_BPS = 100;
  28 | *   |     uint256 internal constant VALID_UNTIL = 1736450876 + 31536000;
  29 | *   |     uint256 internal constant BASE_TOKEN_MIN_RESERVE_AMOUNT = 1e15;
  30 | *   |     uint256 internal constant BASE_TOKEN_MIN_RAISE_AMOUNT = 1e18;
  31 | *   |     uint256 internal constant HARD_CAP = 3600;
  32 | *   |     uint256 internal constant HIGHLIGHTS_BASE_FEE = 5e14;
  33 | *   |     uint256 internal constant COOL_DOWN_PERIOD = 86400;
  34 | *   |     uint256 internal constant PAYOUT_THRESHOLD_WBERA = 0;
  35 | *   |     uint256 internal constant PAYOUT_THRESHOLD_IBGT = 0;
  36 | *   |     uint256 internal constant PAYOUT_THRESHOLD_NECT = 0;
  37 | *   |     address payable internal constant TREASURY = payable(address(0x5));
  38 |     |     address payable internal constant FEE_RECIPIENT = TREASURY;
  39 |     | 
  40 |     |     BuzzTokenFactory internal buzzTokenFactory;
  41 |     |     BuzzVaultExponential internal buzzVaultExponential;
  42 |     |     FeeManager internal feeManager;
  43 |     |     HighlightsManager internal highlightsManager;
  44 |     |     ReferralManager internal referralManager;
  45 |     |     BexLiquidityManagerMock internal bexLiquidityManagerMock;
  46 |     |     CREATE3FactoryMock internal createDeployer;
  47 |     | 
  48 |     |     WBERA internal wBERA;
  49 |     |     ERC20Mock internal iBGT;
  50 |     |     ERC20Mock internal NECT;
  51 |     | 
  52 |     |     User[] internal users;
  53 |     | 
  54 |     |     address[] internal baseTokens;
  55 |     |     address[] internal quoteTokens;
  56 |     | 
  57 |     |     constructor() {
  58 | *   |         _deployBaseTokens();
  59 | *   |         _deployProtocol();
  60 | *   |         _initializeProtocol();
  61 | *   |         _createUsers();
  62 | *   |         _deployTokens();
  63 |     |     }
  64 |     | 
  65 | *   |     function _deployBaseTokens() internal {
  66 | *   |         iBGT = new ERC20Mock("iBGT", "iBGT", 18);
  67 | *   |         NECT = new ERC20Mock("NECT", "NECT", 18);
  68 | *   |         wBERA = new WBERA();
  69 |     |     }
  70 |     | 
  71 | *   |     function _deployProtocol() internal {
  72 | *   |         baseTokens = new address[](NUMBER_OF_BASE_TOKENS);
  73 | *   |         uint256[] memory baseTokenPayouts = new uint256[](
  74 |     |             NUMBER_OF_BASE_TOKENS
  75 |     |         );
  76 |     | 
  77 | *   |         baseTokens[0] = address(wBERA);
  78 | *   |         baseTokens[1] = address(iBGT);
  79 | *   |         baseTokens[2] = address(NECT);
  80 |     | 
  81 | *   |         baseTokenPayouts[0] = PAYOUT_THRESHOLD_WBERA;
  82 | *   |         baseTokenPayouts[1] = PAYOUT_THRESHOLD_IBGT;
  83 | *   |         baseTokenPayouts[2] = PAYOUT_THRESHOLD_NECT;
  84 |     | 
  85 | *   |         feeManager = new FeeManager(
  86 |     |             FEE_RECIPIENT,
  87 |     |             TRADING_FEE_BPS,
  88 |     |             LISTING_FEE,
  89 |     |             MIGRATION_FEE_BPS
  90 |     |         );
  91 | *   |         createDeployer = new CREATE3FactoryMock();
  92 | *   |         buzzTokenFactory = new BuzzTokenFactory(
  93 |     |             //TODO: check owner address
  94 | *   |             address(this),
  95 | *   |             address(createDeployer),
  96 | *   |             address(feeManager)
  97 |     |         );
  98 | *   |         referralManager = new ReferralManager(
  99 |     |             DIRECT_REF_FEE_BPS,
 100 |     |             INDIRECT_REF_FEE_BPS,
 101 |     |             VALID_UNTIL,
 102 | *   |             baseTokens,
 103 | *   |             baseTokenPayouts
 104 |     |         );
 105 | *   |         bexLiquidityManagerMock = new BexLiquidityManagerMock();
 106 | *   |         buzzVaultExponential = new BuzzVaultExponential(
 107 | *   |             address(feeManager),
 108 | *   |             address(buzzTokenFactory),
 109 | *   |             address(referralManager),
 110 | *   |             address(bexLiquidityManagerMock),
 111 | *   |             address(wBERA)
 112 |     |         );
 113 | *   |         highlightsManager = new HighlightsManager(
 114 |     |             FEE_RECIPIENT,
 115 |     |             HARD_CAP,
 116 |     |             HIGHLIGHTS_BASE_FEE,
 117 |     |             COOL_DOWN_PERIOD
 118 |     |         );
 119 |     |     }
 120 |     | 
 121 | *   |     function _initializeProtocol() internal {
 122 | *   |         referralManager.setWhitelistedVault(
 123 | *   |             address(buzzVaultExponential),
 124 | *   |             true
 125 |     |         );
 126 | *   |         buzzTokenFactory.setAllowedBaseToken(
 127 | *   |             address(wBERA),
 128 |     |             BASE_TOKEN_MIN_RESERVE_AMOUNT,
 129 |     |             BASE_TOKEN_MIN_RAISE_AMOUNT,
 130 | *   |             true
 131 |     |         );
 132 | *   |         buzzTokenFactory.setAllowedBaseToken(
 133 | *   |             address(iBGT),
 134 |     |             BASE_TOKEN_MIN_RESERVE_AMOUNT,
 135 |     |             BASE_TOKEN_MIN_RAISE_AMOUNT,
 136 | *   |             true
 137 |     |         );
 138 | *   |         buzzTokenFactory.setAllowedBaseToken(
 139 | *   |             address(NECT),
 140 |     |             BASE_TOKEN_MIN_RESERVE_AMOUNT,
 141 |     |             BASE_TOKEN_MIN_RAISE_AMOUNT,
 142 | *   |             true
 143 |     |         );
 144 | *   |         buzzTokenFactory.setVault(address(buzzVaultExponential), true);
 145 | *   |         buzzTokenFactory.setAllowTokenCreation(true);
 146 |     |     }
 147 |     | 
 148 | *   |     function _createUsers() internal {
 149 | *   |         for (uint256 i = 0; i < NUMBER_OF_USERS; i++) {
 150 | *   |             users.push(new User());
 151 |     |         }
 152 |     |     }
 153 |     | 
 154 | *   |     function _deployTokens() internal {
 155 | *   |         hevm.deal(address(this), LISTING_FEE * 3);
 156 | *   |         address tokenOne = buzzTokenFactory.createToken{value: LISTING_FEE}(
 157 |     |             ["TOKEN 1", "T1"],
 158 | *   |             [address(wBERA), address(buzzVaultExponential)],
 159 | *   |             [uint256(1e18), uint256(100e18)],
 160 | *   |             0,
 161 |     |             "0x1"
 162 |     |         );
 163 | *   |         address tokenTwo = buzzTokenFactory.createToken{value: LISTING_FEE}(
 164 |     |             ["TOKEN 2", "T2"],
 165 | *   |             [address(iBGT), address(buzzVaultExponential)],
 166 | *   |             [uint256(1e18), uint256(100e18)],
 167 | *   |             0,
 168 |     |             "0x2"
 169 |     |         );
 170 | *   |         address tokenThree = buzzTokenFactory.createToken{value: LISTING_FEE}(
 171 |     |             ["TOKEN 3", "T3"],
 172 | *   |             [address(NECT), address(buzzVaultExponential)],
 173 | *   |             [uint256(10000e18), uint256(100000e18)],
 174 | *   |             0,
 175 |     |             "0x3"
 176 |     |         );
 177 |     | 
 178 | *   |         quoteTokens.push(tokenOne);
 179 | *   |         quoteTokens.push(tokenTwo);
 180 | *   |         quoteTokens.push(tokenThree);
 181 |     |     }
 182 |     | }
 183 |     | 

/mnt/c/Users/zerox/repos/bera.buzz-contracts/test/invariant/BuzzProperties.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity ^0.8.19;
   3 |     | 
   4 |     | import {Base} from "./Base.sol";
   5 |     | import {hevm} from "@crytic/properties/contracts/util/Hevm.sol";
   6 |     | import {User} from "./utils/User.sol";
   7 |     | import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
   8 |     | 
   9 | *r  | contract BuzzProperties is Base {
  10 | *   |     uint256 internal constant IBGT_AMOUNT = 1_000_000e18;
  11 | *   |     uint256 internal constant WBERA_AMOUNT = 1_000_000e18;
  12 | *   |     uint256 internal constant NECT_AMOUNT = 100_000_000e18;
  13 |     | 
  14 | *   |     constructor() {
  15 | *   |         for (uint256 i; i < NUMBER_OF_USERS; ++i) {
  16 | *   |             User user = users[i];
  17 |     | 
  18 | *   |             hevm.deal(address(user), WBERA_AMOUNT);
  19 | *   |             hevm.prank(address(user));
  20 | *   |             wBERA.deposit{value: WBERA_AMOUNT}();
  21 | *   |             iBGT.mint(address(user), IBGT_AMOUNT);
  22 | *   |             NECT.mint(address(user), NECT_AMOUNT);
  23 |     | 
  24 | *   |             iBGT.approve(address(buzzTokenFactory), IBGT_AMOUNT);
  25 | *   |             wBERA.approve(address(buzzTokenFactory), WBERA_AMOUNT);
  26 | *   |             NECT.approve(address(buzzTokenFactory), NECT_AMOUNT);
  27 |     | 
  28 | *   |             iBGT.approve(address(buzzVaultExponential), IBGT_AMOUNT);
  29 | *   |             wBERA.approve(address(buzzVaultExponential), WBERA_AMOUNT);
  30 | *   |             NECT.approve(address(buzzVaultExponential), NECT_AMOUNT);
  31 |     |         }
  32 |     |     }
  33 |     | 
  34 |     |     // ---------------------- Handlers -------------------------------
  35 |     | 
  36 | *   |     function buy(
  37 |     |         uint256 randToken,
  38 |     |         uint256 randBaseAmount,
  39 |     |         uint256 randMinTokensOut
  40 |     |     ) public {
  41 | *   |         User user = users[randToken % users.length];
  42 |     | 
  43 | *   |         address token = quoteTokens[randToken % quoteTokens.length];
  44 | *   |         address baseToken = baseTokens[randToken % baseTokens.length];
  45 | *   |         uint256 amount = clampBetween(
  46 | *   |             randBaseAmount,
  47 | *   |             1,
  48 | *   |             IERC20(baseToken).balanceOf(address(user))
  49 |     |         );
  50 | *   |         uint256 minAmountOut = clampBetween(randMinTokensOut, 1, amount);
  51 | *   |         require(IERC20(baseToken).balanceOf(address(user)) >= amount);
  52 |     | 
  53 | *   |         (bool success, ) = user.proxy(
  54 | *   |             address(buzzTokenFactory),
  55 | *   |             abi.encodeWithSelector(
  56 | *   |                 buzzVaultExponential.buy.selector,
  57 | *   |                 token,
  58 | *   |                 amount,
  59 | *   |                 minAmountOut,
  60 | *   |                 address(0),
  61 | *   |                 address(user)
  62 |     |             )
  63 |     |         );
  64 | *r  |         require(success);
  65 |     |     }
  66 |     | 
  67 | *   |     function sell(
  68 |     |         uint256 randToken,
  69 |     |         uint256 randTokenAmount,
  70 |     |         uint256 randMinBaseOut
  71 |     |     ) public {
  72 | *   |         User user = users[randToken % users.length];
  73 |     | 
  74 | *   |         address token = quoteTokens[randToken % quoteTokens.length];
  75 | *   |         address baseToken = baseTokens[randToken % baseTokens.length];
  76 | *   |         uint256 amount = clampBetween(
  77 | *   |             randTokenAmount,
  78 | *   |             1,
  79 | *   |             IERC20(token).balanceOf(address(user))
  80 |     |         );
  81 |     |         uint256 minAmountOut = clampBetween(randMinBaseOut, 1, amount);
  82 |     |         require(
  83 |     |             IERC20(baseToken).balanceOf(address(buzzTokenFactory)) >= amount
  84 |     |         );
  85 |     | 
  86 |     |         (bool success, ) = user.proxy(
  87 |     |             address(buzzTokenFactory),
  88 |     |             abi.encodeWithSelector(
  89 |     |                 buzzVaultExponential.sell.selector,
  90 |     |                 token,
  91 |     |                 amount,
  92 |     |                 minAmountOut,
  93 |     |                 address(0),
  94 |     |                 address(user),
  95 |     |                 false
  96 |     |             )
  97 |     |         );
  98 |     |         require(success);
  99 |     |     }
 100 |     | 
 101 | *   |     function quote(uint256 randToken, uint256 randAmount) public {
 102 | *   |         User user = users[randToken % users.length];
 103 | *   |         bool isBuyOrder = randToken % 2 == 0;
 104 |     | 
 105 | *   |         address token = quoteTokens[randToken % quoteTokens.length];
 106 | *   |         address baseToken = baseTokens[randToken % baseTokens.length];
 107 | *   |         uint256 amount = isBuyOrder
 108 | *   |             ? clampBetween(
 109 | *   |                 randAmount,
 110 | *   |                 1,
 111 | *   |                 IERC20(baseToken).balanceOf(address(user))
 112 |     |             )
 113 | *   |             : clampBetween(
 114 | *   |                 randAmount,
 115 | *   |                 1,
 116 | *   |                 IERC20(token).balanceOf(address(user))
 117 |     |             );
 118 | *   |         require(
 119 | *   |             isBuyOrder
 120 | *   |                 ? IERC20(baseToken).balanceOf(address(user)) >= amount
 121 |     |                 : IERC20(baseToken).balanceOf(address(buzzTokenFactory)) >=
 122 |     |                     amount
 123 |     |         );
 124 |     | 
 125 | *   |         (bool success, ) = user.proxy(
 126 | *   |             address(buzzTokenFactory),
 127 | *   |             abi.encodeWithSelector(
 128 | *   |                 buzzVaultExponential.quote.selector,
 129 | *   |                 token,
 130 | *   |                 amount,
 131 | *   |                 isBuyOrder
 132 |     |             )
 133 |     |         );
 134 | *r  |         require(success);
 135 |     |     }
 136 |     | 
 137 | *   |     function claimReferralReward(uint256 randToken) public {
 138 | *   |         User user = users[randToken % users.length];
 139 |     | 
 140 | *   |         address token = quoteTokens[randToken % quoteTokens.length];
 141 | *   |         address baseToken = baseTokens[randToken % baseTokens.length];
 142 |     |         //TODO: change requirement to only feed tx if referral reward is available
 143 | *r  |         require(IERC20(baseToken).balanceOf(address(referralManager)) >= 1);
 144 |     | 
 145 |     |         (bool success, ) = user.proxy(
 146 |     |             address(referralManager),
 147 |     |             abi.encodeWithSelector(
 148 |     |                 referralManager.claimReferralReward.selector,
 149 |     |                 token
 150 |     |             )
 151 |     |         );
 152 |     |         require(success);
 153 |     |     }
 154 |     | 
 155 | *   |     function highlightToken(uint256 randToken, uint256 randDuration) public {
 156 | *   |         User user = users[randToken % users.length];
 157 |     | 
 158 | *   |         address token = quoteTokens[randToken % quoteTokens.length];
 159 | *   |         uint256 duration = clampBetween(randDuration, 60, HARD_CAP);
 160 | *   |         require(highlightsManager.bookedUntil() <= block.timestamp);
 161 | *   |         require(highlightsManager.tokenCoolDownUntil(token) <= block.timestamp);
 162 |     | 
 163 | *r  |         (bool success, ) = user.payableProxy{
 164 | *   |             value: highlightsManager.quote(duration)
 165 |     |         }(
 166 | *   |             address(highlightsManager),
 167 | *   |             abi.encodeWithSelector(
 168 | *   |                 highlightsManager.highlightToken.selector,
 169 | *   |                 token,
 170 | *   |                 duration
 171 |     |             )
 172 |     |         );
 173 |     |         require(success);
 174 |     |     }
 175 |     | 
 176 | *   |     function highlightsQuote(uint256 randDuration) public {
 177 | *   |         User user = users[randDuration % users.length];
 178 |     | 
 179 | *   |         uint256 duration = clampBetween(randDuration, 60, HARD_CAP);
 180 |     | 
 181 | *   |         (bool success, ) = user.proxy(
 182 | *   |             address(highlightsManager),
 183 | *   |             abi.encodeWithSelector(highlightsManager.quote.selector, duration)
 184 |     |         );
 185 | *   |         require(success);
 186 |     |     }
 187 |     | 
 188 |     |     // ---------------------- Invariants -------------------------------
 189 |     | 
 190 |     |     /// @custom:invariant The product of tokenBalance and baseBalance must always equal the constant product (K)
 191 | *   |     function constantProduct(uint256 randToken) public {
 192 | *   |         address token = quoteTokens[randToken % quoteTokens.length];
 193 | *   |         (,,uint256 tokenBalance, uint256 baseBalance,,,,uint256 k) = buzzVaultExponential.tokenInfo(token);
 194 |     | 
 195 | *   |         assert (tokenBalance * baseBalance == k);
 196 |     |     }
 197 |     | }
 198 |     | 

/mnt/c/Users/zerox/repos/bera.buzz-contracts/test/invariant/mocks/BexLiquidityManagerMock.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.19;
  3 |     | 
  4 |     | import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
  5 |     | import {SafeERC20} from "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
  6 |     | import {SqrtMath} from "../../../contracts/libraries/SqrtMath.sol";
  7 |     | 
  8 | *   | contract BexLiquidityManagerMock {
  9 |     |     using SafeERC20 for IERC20;
 10 |     | 
 11 |     |     function createPoolAndAdd(
 12 |     |         address token,
 13 |     |         address baseToken,
 14 |     |         uint256 baseAmount,
 15 |     |         uint256 amount
 16 |     |     ) external {
 17 |     |         // Transfer and approve tokens
 18 |     |         IERC20(token).safeTransferFrom(msg.sender, address(this), amount);
 19 |     |         IERC20(baseToken).safeTransferFrom(
 20 |     |             msg.sender,
 21 |     |             address(this),
 22 |     |             baseAmount
 23 |     |         );
 24 |     |         IERC20(token).safeTransfer(address(0xdead), amount);
 25 |     |         IERC20(baseToken).safeTransfer(address(0xdead), baseAmount);
 26 |     |     }
 27 |     | }
 28 |     | 

/mnt/c/Users/zerox/repos/bera.buzz-contracts/test/invariant/mocks/ERC20Mock.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.19;
  3 |     | 
  4 |     | import {ERC20} from "@openzeppelin/contracts/token/ERC20/ERC20.sol";
  5 |     | 
  6 | *   | contract ERC20Mock is ERC20 {
  7 |     |     uint8 internal immutable dec;
  8 |     | 
  9 | *   |     constructor(
 10 |     |         string memory _name,
 11 |     |         string memory _symbol,
 12 |     |         uint8 _dec
 13 | *   |     ) ERC20(_name, _symbol) {
 14 | *   |         dec = _dec;
 15 |     |     }
 16 |     | 
 17 |     |     function decimals() public view virtual override returns (uint8) {
 18 |     |         return dec;
 19 |     |     }
 20 |     | 
 21 | *   |     function mint(address account, uint256 amount) external {
 22 | *   |         _mint(account, amount);
 23 |     |     }
 24 |     | 
 25 |     |     function burn(address account, uint256 amount) external {
 26 |     |         _burn(account, amount);
 27 |     |     }
 28 |     | }
 29 |     | 

/mnt/c/Users/zerox/repos/bera.buzz-contracts/test/invariant/utils/User.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.19;
  3 |     | 
  4 |     | import {ERC20} from "@openzeppelin/contracts/token/ERC20/ERC20.sol";
  5 |     | 
  6 | *   | contract User {
  7 |     |     constructor() payable {}
  8 |     | 
  9 | *   |     function proxy(
 10 |     |         address target,
 11 |     |         bytes memory data
 12 | *   |     ) public returns (bool success, bytes memory err) {
 13 | *   |         return target.call(data);
 14 |     |     }
 15 |     | 
 16 |     |     function payableProxy(
 17 |     |         address target,
 18 |     |         bytes memory data
 19 |     |     ) public payable returns (bool success, bytes memory err) {
 20 |     |         return target.call{value: msg.value}(data);
 21 |     |     }
 22 |     | 
 23 |     |     function approve(address target, address spender) public {
 24 |     |         ERC20(target).approve(spender, type(uint256).max);
 25 |     |     }
 26 |     | }
 27 |     | 

